.module Z80CCP

CCP0	=	0xD300		; 0xD300 = CCP start 		(0xD300 - 0xDB06)		2054 bytes	= 18 sectors
BDOS0	=	0xDC00		; 0xDC00 = BDOS loaded here	(0xDC00 - 0xECFA)		3578 bytes	= 28 sectors
BIOS	=	0xEA00		; 0xEA00 = BIOS start 		(0xEA00 - 0xFC00)		4096 bytes



;*
;*  ENHANCED CP/M CONSOLE COMMAND PROCESSOR (CCP) for CP/M REV. 2.2
;*
;*	Original CCP disassembled by ????
;*	Original CCP disassembled further by RLC
;*	Original CCP commented by RLC
;*	Modified and generalized by John Thomas (6/20/81)
;*	Macros expanded and condtional for terminals which
;*	     use form feeds to clear the screen added by
;*	     Bo McCormick (6/27/81)
;*      Hacked to assemble with ZSM by Michael Haardt (2/21/96)
;*
;***** ASSEMBLING THIS CCP FOR CP/M 2.2 *****
;*	You must be using a Z-80 processor to run this
;*	program. You do not need MAC or any macro library.
;*	If you add further modifications to the program
;*	the total size of the program must not exceed
;*	2K in order to fit under the BDOS.
;*	Code must be added to use the Clear Screen command with
;*	your terminal. Equates exist for the Hazeltine 1500,
;*	the Heath/Zenith H19/H89, and any terminal which uses
;*	a form feed to clear the screen.
;*	Also, there is a provision for a boot-up command. Place
;*	the command to be executed on cold and warm starts at 
;*	location CBUFF.
;*
;***** NON-STANDARD FEATURES *****
;*	The non-standard features incorporated into this CCP are:
;*	  A.  The Command-Search Hierarchy, as follows --
;*		1.  Scan for a CCP-resident command and execute it if
;*			found
;*		2.  If not CCP-resident, look for a .COM file on disk
;*		3.  If the .COM file is not found in the current user
;*			area and the current user area is not USER 0,
;*			USER 0 is selected and scanned for the file
;*		4.  If the .COM file is not found on the current
;*			logged-in disk drive, drive A: is selected
;*			and scanned for the file
;*	  B.  The DIR Command no longer prints the current drive spec
;*		at the beginning of each line
;*	  C.  The TYPE Command pages its output
;*	  D.  A LIST Command now exists which is like TYPE but does not
;*		page and sends its output to the LST: device
;*	  E.  A CLS (Clear Screen) Command now exists which clears the
;*		screen of the terminal
;*	  F.  The user number is printed as part of the command prompt;
;*		the prompt is now du>, such as A0> and A15>
;*	  G.  Z80-code is used throughout to reduce the size of the CCP
;*		and give room to implement the additional functions
;*	  H.  The input line buffer has been reduced in size to 100 bytes
;*	  I.  The ERA Command displays the names of the files it is to
;*		erase
;*	  J.  The DIR Command has an additional special form of "DIR @"
;*		which displays all files (both non-system and system),
;*		while "DIR" displays just the non-system files
;*	  K.  The Directory Display no longer displays the disk name at
;*		the beginning of each line and it now includes a '.' between
;*		the file name and file type (FILENAME.TYP)
;*	  L.  The SUBMIT File Facility now expects the $$$.SUB file to be
;*		on the currently logged-in disk (as opposed to always A:)
;*	  M.  The Command Line Prompt is now '$' if the command comes from
;*		a $$$.SUB file and '>' if the command comes from the user;
;*		also, the '>' is not printed until all preprocessing is
;*		completed
;*	  N.  The TYPE and LIST Commands mask the MSB of each byte, so that
;*		files created by editors such as EDIT80 are "printable"
;*

FALSE		=	0
TRUE		=	255
 
NLINES	= 24		; NUMBER OF LINES ON CRT SCREEN

H19		= FALSE		; USING HEATH H19/H89 TERMINAL
HAZE		= FALSE		; USING HAZELTINE 1500 TERMINAL
FFTERM		= TRUE		; USING TERMINAL THAT RESPONDS TO 0CH
									; OR ANY CHARACTER IF YOU CHANGE THE
									; VALUE OF FF BELOW

CR			= 0x0D
LF			= 0x0A
TAB			= 0x09
FF			= 0x0C		;<==== CHANGE THIS BYTE IF TERMINAL
ESC			= 0x1B		;      NEEDS A DIFFERENT CHARACTER
									;      TO CLEAR THE SCREEN

 
WBOOT	= 0x0000		; CP/M WARM BOOT ADDRESS
UDFLAG	= 0x0004		; USER NUMBER IS IN HIGH NYBBLE, DISK IN LOW
BDOS	= 0x0005		; BDOS FUNCTION CALL ENTRY PT
TBUFF	= 0x0080		; DEFAULT DISK I/O BUFFER
TFCB	= 0x005C		; DEFAULT FCB BUFFER
TPA			= 0x0100		; BASE OF TPA
 
BUFLEN	= 100		; MAXIMUM BUFFER LENGTH




.area _HEADER (ABS)
	.ORG	CCP0		;(MEM-7)*1024; ;(MEM-7)*1024

ENTRY:
	JP	CCP
	JP	CCP1
 
;*  INPUT COMMAND LINE AND DEFAULT COMMAND
MBUFF:
	.DB	BUFLEN		; MAXIMUM BUFFER LENGTH
CBUFF:
	.DB	0		;<== NUMBER OF VALID CHARS IN COMMAND LINE
CIBUFF:
	.ascii	'    '		;<== DEFAULT (COLD BOOT) COMMAND
	.ascii	'    '
	.ascii	'    '
	.ascii	'    '
CIBUF:
	.DS	85		; TOTAL IS 100 BYTES
	.DS	20		; STACK AREA
STACK:				; TOP OF STACK
 
CIBPTR:
	.DW	CIBUFF		;POINTER TO CMD INPUT BUFF
CIPTR:
	.DW	CIBUF		;CURRENT PNTR
 
;*
;*  I/O UTILITIES
;*
 
;*  OUTPUT <SP>
SPACER:
	LD	A, #" "	; FALL THRU TO CONOUT
 
;*  OUTPUT CHAR IN REG A TO CONSOLE AND DON'T CHANGE BC
CONOUT:
	PUSH	BC
	PUSH	HL
	LD	C,#2
OUTPUT:
	LD	E,A
	CALL	BDOS
	POP	HL
	POP	BC
	RET
 
;*  CALL BDOS AND SAVE BC
BDOSB:
	PUSH	BC
	CALL	BDOS
	POP	BC
	RET
 
;*  OUTPUT CHAR IN REG A TO LIST DEVICE
LSTOUT:
	PUSH	BC
	PUSH	HL
	LD	C,#5
	JR	OUTPUT
 
;*  OUTPUT <CRLF>
CRLF:
	LD	A,#CR
	CALL	CONOUT
	LD	A,#LF
	JR	CONOUT
 
;*  PRINT STRING (ENDING IN 0) PTED TO BY RET ADR; START WITH <CRLF>
PRINT:
	EX	(SP),HL		; GET PTR TO STRING
	PUSH	AF		; SAVE FLAGS
	CALL	CRLF		; NEW LINE
	CALL	PRIN1
	POP	AF		; GET FLAGS
	EX	(SP),HL		; RESTORE HL AND RET ADR
	RET
 
;*  PRINT STRING (ENDING IN 0) PTED TO BY HL
PRIN1:
	LD	A,(HL)		; GET NEXT BYTE
	INC	HL		; PT TO NEXT BYTE
	OR	A		; DONE IF 0
	RET	Z
	CALL	CONOUT		; PRINT CHAR
	JR	PRIN1
 
;*
;*  BDOS FUNCTION ROUTINES
;*
 
RESET:
	LD	C,#0x0D
	JP	BDOS
;
LOGIN:
	LD	E,A
	LD	C,#0x0E
	JP	BDOS
;
OPENF:
	XOR	A
	LD	(FCBCR),A
	LD	DE,#FCBDN	; FALL THRU TO OPEN
;
OPEN:
	LD	C,#0x0F	; FALL THRU TO GRBDOS
;
GRBDOS:
	CALL	BDOS
	INC	A	; SET ZERO FLAG FOR ERROR RETURN
	RET
;
CLOSE:
	LD	C,#0x10
	JR	GRBDOS
;
SEARF:
	LD	DE,#FCBDN	; SPECIFY FCB
SEAR1:
	LD	C,#0x11		; BDOS 17, SEARCH FOR FIRST
	JR	GRBDOS
;
SEARN:
	LD	C,#0x12
	JR	GRBDOS
;
DELETE:
	LD	C,#0x13
	JP	BDOS
;
READF:
	LD	DE,#FCBDN	; FALL THRU TO READ
;
READ:
	LD	C,#0x14	; FALL THRU TO GOBDOS
;
GOBDOS:
	CALL	BDOSB	; PRESERVE B
	OR	A
	RET	
;
WRITE:
	LD	C,#0x15
	JR	GOBDOS
;
CREATE:
	LD	C,#0x16
	JR	GRBDOS
;
GETUSR:
	LD	E,#0xFF		;GET CURRENT USER NUMBER
SETUSR:
	LD	C,#0x20		;SET USER NUMBER TO VALUE IN E (GET IF E=FFH)
	JP	BDOS
 
;*
;*  END OF BDOS FUNCTIONS
;*
 
;*
;*  CCP UTILITIES
;*
 
;*  SET USER/DISK FLAG TO CURRENT USER AND DEFAULT DISK
SETUD:
	CALL	GETUSR		; GET NUMBER OF CURRENT USER
	ADD	A,A		; PLACE IT IN HIGH NYBBLE
	ADD	A,A
	ADD	A,A
	ADD	A,A
	LD	HL,#TDRIVE	; MASK IN DEFAULT DRIVE NUMBER (LOW NYBBLE)
	OR	(HL)		; MASK IN
	LD	(UDFLAG),A	; SET USER/DISK NUMBER
	RET
 
;*  SET USER/DISK FLAG TO USER 0 AND DEFAULT DISK
SETU0D:
	LD	A,(TDRIVE)	; SET USER 0/DEFAULT DISK
	LD	(UDFLAG),A	; SET USER/DISK NUMBER
	RET
 
;*  CONVERT CHAR IN A TO UPPER CASE
UCASE:
	CP	#0x61		; LOWER-CASE A
	RET	C
	CP	#0x7B		; GREATER THAN LOWER-CASE Z?
	RET	NC
	AND	#0x5F		; CAPITALIZE
	RET
 
;*  INPUT NEXT COMMAND TO CCP
REDBUF:
	LD	A,(RNGSUB)	; SUBMIT FILE CURRENTLY IN EXECUTION?
	OR	A		; 0=NO
	JR	Z,RB1		; GET LINE FROM CONSOLE IF NOT
	LD	DE,#SUBFCB	; OPEN $$$.SUB
	CALL	OPEN
	JR	Z,RB1		; ERASE $$$.SUB IF END OF FILE AND GET CMND
	LD	A,(SUBFRC)	; GET VALUE OF LAST RECORD IN FILE
	DEC	A		; PT TO NEXT TO LAST RECORD
	LD	(SUBFCR),A	; SAVE NEW VALUE OF LAST RECORD IN $$$.SUB
	LD	DE,#SUBFCB	; READ LAST RECORD OF SUBMIT FILE
	CALL	READ
	JR	NZ,RB1		; ABORT $$$.SUB IF ERROR IN READING LAST REC
	LD	DE,#CBUFF	; COPY LAST RECORD (NEXT SUBMIT CMND) TO CBUFF
	LD	HL,#TBUFF	;   FROM TBUFF
	LD	B,#BUFLEN	; NUMBER OF BYTES
	CALL	MOVEHD
	LD	HL,#SUBFS2	; PT TO S2 OF $$$.SUB FCB
	LD	(HL),#0		; SET S2 TO ZERO
	INC	HL		; PT TO RECORD COUNT
	DEC	(HL)		; DECREMENT RECORD COUNT OF $$$.SUB
	LD	DE,#SUBFCB	; CLOSE $$$.SUB
	CALL	CLOSE
	JR	Z,RB1		; ABORT $$$.SUB IF ERROR
	LD	A,#"$"		; PRINT SUBMIT PROMPT
	CALL	CONOUT
	LD	HL,#CIBUFF	; PRINT COMMAND LINE FROM $$$.SUB
	CALL	PRIN1
	CALL	BREAK		; CHECK FOR ABORT (ANY CHAR)
	JR	Z,CNVBUF	; IF <NULL> (NO ABORT), CAP COMMAND AND RUN
	CALL	SUBKIL		; KILL $$$.SUB IF ABORT
	JP	RESTRT		; RESTART CCP
 
;*  INPUT COMMAND LINE FROM USER CONSOLE
RB1:
	CALL	SUBKIL		; ERASE $$$.SUB IF PRESENT
	CALL	SETUD		; SET USER AND DISK
	LD	A,#">"		; PRINT PROMPT
	CALL	CONOUT
	LD	C,#0x0A		; READ COMMAND LINE FROM USER
	LD	DE,#MBUFF
	CALL	BDOS
	CALL	SETU0D		; SET CURRENT DISK NUMBER IN LOWER PARAMS
 
;*  CAPITALIZE STRING (ENDING IN 0) IN CBUFF
CNVBUF:
;	OUT	(0xD2), A
	LD	HL,#CBUFF	; PT TO USER'S COMMAND
	LD	B,(HL)		; CHAR COUNT IN B
CB1:
	INC	HL		; PT TO 1ST VALID CHAR
	LD	A,B		; DONE WHEN <NULL> ENCOUNTERED
	OR	A
	JR	Z,CB2
	LD	A,(HL)		; CAPITALIZE COMMAND CHAR
	CP	#32
	JR	NC, CB1B
	LD	A, #"^"
CB1B:
	CALL	UCASE
	LD	(HL),A
	DEC	B		; CONTINUE UNTIL END OF COMMAND LINE
	JR	CB1
CB2:
	LD	(HL),A		; STORE ENDING <NULL>
	LD	HL,#CIBUFF	; SET COMMAND LINE PTR TO 1ST CHAR
	LD	(CIBPTR),HL
	RET
 
;*  CHECK FOR ANY CHAR FROM USER CONSOLE; RET W/ZERO SET IF NONE
BREAK:
	PUSH	DE		; SAVE DE
	LD	E,#0xFF		; GET STATUS
	LD	C,#6		; DIRECT CONSOLE I/O
	CALL	BDOSB
	POP	DE
	AND	#0x7F		; MASK MSB AND SET ZERO FLAG
	RET
 
;*  RETURN NUMBER OF CURRENT DISK IN A
GETDRV:
	LD	C,#0x19
	JP	BDOS
 
;*  SET 80H AS DMA ADDRESS
DEFDMA:
	LD	DE,#TBUFF		; 80H=TBUFF
DMASET:
	LD	C,#0x1A
	JP	BDOS
 
;*  CHECK FOR SUBMIT FILE IN EXECUTION AND ABORT IT IF SO
SUBKIL:
	LD	HL,#RNGSUB	; CHECK FOR SUBMIT FILE IN EXECUTION
	LD	A,(HL)
	OR	A		; 0=NO
	RET	Z
	LD	(HL),#0		; ABORT SUBMIT FILE
	LD	DE,#SUBFCB	; DELETE $$$.SUB
	JP	DELETE
 
;*  INVALID COMMAND -- PRINT IT
ERROR:
	CALL	CRLF		; NEW LINE
	LD	HL,(CIPTR)	; PT TO BEGINNING OF COMMAND LINE
ERR2:
	LD	A,(HL)		; GET CHAR
	CP	#" "		; SIMPLE '?' IF <SP>
	JR	Z,ERR1
	OR	A		; SIMPLE '?' IF <NULL>
	JR	Z,ERR1
	PUSH	HL		; SAVE PTR TO ERROR COMMAND CHAR
	CALL	CONOUT		; PRINT COMMAND CHAR
	POP	HL		; GET PTR
	INC	HL		; PT TO NEXT
	JR	ERR2		; CONTINUE
ERR1:
	LD	A,#"?"		; PRINT '?'
	CALL	CONOUT
	CALL	SUBKIL		; TERMINATE ACTIVE $$$.SUB IF ANY
	JP	RESTRT		; RESTART CCP
 
;*  CHECK TO SEE IF DE PTS TO DELIMITER; IF SO, RET W/ZERO FLAG SET
SDELM:
	LD	A,(DE)
	OR	A		; 0=DELIMITER
	RET	Z
	CP	#" "		; ERROR IF < <SP>
	JP	C,ERROR
	RET	Z		; <SP>=DELIMITER
	CP	#"="		; '='=DELIMITER
	RET	Z
	CP	#0x5F		; UNDERSCORE=DELIMITER
	RET	Z
	CP	#"."		; '.'=DELIMITER
	RET	Z
	CP	#":"		; ':'=DELIMITER
	RET	Z
	CP	#59		; ';'=DELIMITER
	RET	Z
	CP	#"<"		; '<'=DELIMITER
	RET	Z
	CP	#">"		; '>'=DELIMITER
	RET
 
;*  SKIP STRING PTED TO BY DE (STRING ENDS IN 0) UNTIL END OF STRING
;*    OR NON-BLANK ENCOUNTERED (BEGINNING OF TOKEN)
SBLANK:
	LD	A,(DE)
	OR	A
	RET	Z
	CP	#" "
	RET	NZ
	INC	DE
	JR	SBLANK
 
;*  ADD A TO HL (HL=HL+A)
ADDAH:
	ADD	A,L
	LD	L,A
	RET	NC
	INC	H
	RET
 
;*  EXTRACT TOKEN FROM COMMAND LINE AND PLACE IT INTO FCBDN; FORMAT FCBDN
;*    IF TOKEN RESEMBLES FILE NAME AND TYPE (FILENAME.TYP);
;*    ON INPUT,  CIBPTR PTS TO CHAR AT WHICH TO START SCAN
;*    ON OUTPUT, CIBPTR PTS TO CHAR AT WHICH TO CONTINUE AND ZERO FLAG IS SET
;*      IF '?' IS IN TOKEN
SCANNER:
	LD	A,#0		; START AT DRIVE SPECIFICATION BYTE
SCAN1:
	LD	HL,#FCBDN	; POINT TO FCBDN
	CALL	ADDAH		; OFFSET INTO FCB
	PUSH	HL
	PUSH	HL
	XOR	A		; SET TEMPORARY DRIVE NUMBER TO DEFAULT
	LD	(TEMPDR),A
	LD	HL,(CIBPTR)	; GET PTR TO NEXT CHAR IN COMMAND LINE
	EX	DE,HL		; PTR IN DE
	CALL	SBLANK		; SKIP TO NON-BLANK OR END OF LINE
	EX	DE,HL
	LD	(CIPTR),HL	; SET PTR TO NON-BLANK OR END OF LINE
	EX	DE,HL			; DE PTS TO NEXT NON-BLANK OR END OF LINE CHAR
	POP	HL		; GET PTR TO NEXT BYTE IN FCBDN
	LD	A,(DE)		; END OF LINE?
	OR	A		; 0=YES
	JR	Z,SCAN2
	SBC	A,#"A"-1	; CONVERT POSSIBLE DRIVE SPEC TO NUMBER
	LD	B,A		; STORE NUMBER (A:=0, B:=1, ETC) IN B
	INC	DE		; PT TO NEXT CHAR
	LD	A,(DE)		; SEE IF IT IS A COLON (:)
	CP	#":"
	JR	Z,SCAN3		; YES^  WE HAVE A DRIVE SPEC
	DEC	DE		; NO^  BACK UP PTR TO FIRST NON-BLANK CHAR
SCAN2:
	LD	A,(TDRIVE)	; SET 1ST BYTE OF FCBDN AS DEFAULT DRIVE
	LD	(HL),A
	JR	SCAN4
SCAN3:
	LD	A,B		; WE HAVE A DRIVE SPEC^
	LD	(TEMPDR),A	; SET TEMPORARY DRIVE
	LD	(HL),B		; SET 1ST BYTE OF FCBDN AS SPECIFIED DRIVE
	INC	DE		; PT TO BYTE AFTER ':'
 
;*  EXTRACT FILENAME FROM POSSIBLE FILENAME.TYP
SCAN4:
	LD	B,#8		; MAX OF 8 CHARS IN FILE NAME
SCAN5:
	CALL	SDELM		; DONE IF DELIMITER ENCOUNTERED - <SP> FILL
	JR	Z,SCAN9
	INC	HL		; PT TO NEXT BYTE IN FCBDN
	CP	#"*"		; IS (DE) A WILD CARD?
	JR	NZ,SCAN6	; CONTINUE IF NOT
	LD	(HL),#"?"	; PLACE '?' IN FCBDN AND DON'T ADVANCE DE IF SO
	JR	SCAN7
SCAN6:
	LD	(HL),A		; STORE FILENAME CHAR IN FCBDN
	INC	DE		; PT TO NEXT CHAR IN COMMAND LINE
SCAN7:
	DJNZ	SCAN5		; DECREMENT CHAR COUNT UNTIL 8 ELAPSED
SCAN8:
	CALL	SDELM		; 8 CHARS OR MORE - SKIP UNTIL DELIMITER
	JR	Z,SCAN10	; ZERO FLAG SET IF DELIMITER FOUND
	INC	DE		; PT TO NEXT CHAR IN COMMAND LINE
	JR	SCAN8
SCAN9:
	INC	HL		; PT TO NEXT BYTE IN FCBDN
	LD	(HL),#" "	; FILL FILENAME PART WITH <SP>
	DJNZ	SCAN9
 
;*  EXTRACT FILE TYPE FROM POSSIBLE FILENAME.TYP
SCAN10:
	LD	B,#3		; PREPARE TO EXTRACT TYPE
	CP	#"."		; IF (DE) DELIMITER IS A ".", WE HAVE A TYPE
	JR	NZ,SCAN15	; FILL FILE TYPE BYTES WITH <SP>
	INC	DE		; PT TO CHAR IN COMMAND LINE AFTER '.'
SCAN11:
	CALL	SDELM		; CHECK FOR DELIMITER
	JR	Z,SCAN15	; FILL REST OF TYPE IF IT IS A DELIMITER
	INC	HL		; PT TO NEXT BYTE IN FCBDN
	CP	#"*"		; WILD?
	JR	NZ,SCAN12	; STORE CHAR IF NOT WILD
	LD	(HL),#"?"	; STORE '?' AND DON'T ADVANCE COMMAND LINE PTR
	JR	SCAN13
SCAN12:
	LD	(HL),A		; STORE CHAR IN FCBDN
	INC	DE		; PT TO NEXT CHAR IN COMMAND LINE
SCAN13:
	DJNZ	SCAN11		; COUNT DOWN CHARS IN FILE TYPE (3 MAX)
SCAN14:
	CALL	SDELM		; SKIP REST OF CHARS AFTER 3-CHAR TYPE TO
	JR	Z,SCAN16	;   DELIMITER
	INC	DE
	JR	SCAN14
SCAN15:
	INC	HL		; FILL IN REST OF TYP WITH <SP>
	LD	(HL),#" "
	DJNZ	SCAN15
 
;*  FILL IN EX, S1, S2, AND RC WITH ZEROES
SCAN16:
	LD	B,#4		; 4 BYTES
SCAN17:
	INC	HL		; PT TO NEXT BYTE IN FCBDN
	LD	(HL),#0
	DJNZ	SCAN17
 
;*  SCAN COMPLETE -- DE PTS TO DELIMITER BYTE AFTER TOKEN
	EX	DE,HL		; STORE PTR TO NEXT BYTE IN COMMAND LINE
	LD	(CIBPTR),HL
 
;*  SET ZERO FLAG TO INDICATE PRESENCE OF '?' IN FILENAME.TYP
	POP	HL		; GET PTR TO FCBDN IN HL
	LD	BC,#11		; SCAN FOR '?' IN FILENAME.TYP (C=11 BYTES)
SCAN18:
	INC	HL		; PT TO NEXT BYTE IN FCBDN
	LD	A,(HL)
	CP	#"?"
	JR	NZ,SCAN19
	INC	B		; B<>0 TO INDICATE '?' ENCOUNTERED
SCAN19:
	DEC	C		; COUNT DOWN
	JR	NZ,SCAN18
	LD	A,B		; A=B=NUMBER OF '?' IN FILENAME.TYP
	OR	A		; SET ZERO FLAG TO INDICATE ANY '?'
	RET
 
;*
;*  CCP BUILT-IN COMMAND TABLE AND COMMAND PROCESSOR
;*
NCMNDS	= 8		; NUMBER OF CCP COMMANDS
NCHARS	= 4		; NUMBER OF CHARS/COMMAND
;*  CCP COMMAND NAME TABLE
CMDTBL:
	.ascii	'DIR '
	.ascii	'ERA '
	.ascii	'LIST'
	.ascii	'TYPE'

	.ascii	'SAVE'
	.ascii	'REN '
	.ascii	'USER'
	.ascii	'CLS '

;*  CCP COMMAND ADDRESS TABLE
REQTBL:
	.DW	DIR
	.DW	ERA
	.DW	LIST
	.DW	TYPE

	.DW	SAVE
	.DW	REN
	.DW	USER
	.DW	CLS

	.DW	COM		;MUST BE A COM FILE
 
;*  CMDTBL (COMMAND TABLE) SCANNER
;*    ON RETURN, A=TABLE ENTRY # (0-5) OR 6 IF NOT FOUND (COM FILE)
CMDSER:
	LD	HL,#CMDTBL	; PT TO COMMAND TABLE
	LD	C,#0		; SET COMMAND COUNTER
CMS1:
	LD	A,C		; CHECK FOR DONE
	CP	#NCMNDS		; NUMBER OF COMMANDS
	RET	NC
	LD	DE,#FCBFN	; PT TO STORED COMMAND NAME
	LD	B,#NCHARS	; NUMBER OF CHARS/COMMAND (8 MAX)
CMS2:
	LD	A,(DE)		; COMPARE AGAINST TABLE ENTRY
	CP	(HL)
	JR	NZ,CMS3		; NO MATCH
	INC	DE		; PT TO NEXT CHAR
	INC	HL
	DJNZ	CMS2		; COUNT DOWN
	LD	A,(DE)		; NEXT CHAR IN INPUT COMMAND MUST BE <SP>
	CP	#" "
	JR	NZ,CMS4
	LD	A,C		; TABLE ENTRY NUMBER IN A
	RET
CMS3:
	INC	HL		; SKIP TO NEXT COMMAND TABLE ENTRY
	DJNZ	CMS3
CMS4:
	INC	C		; INCREMENT TABLE ENTRY NUMBER
	JR	CMS1
 
;*
;*  CCP STARTING POINTS
;*
 
;*  START CCP AND DON'T PROCESS DEFAULT COMMAND STORED
CCP1:
	XOR	A		; SET NO DEFAULT COMMAND
	LD	(CBUFF),A
 
;*  START CCP AND POSSIBLY PROCESS DEFAULT COMMAND
CCP:
	LD	SP,#STACK	; RESET STACK
	PUSH	BC
	LD	A,C		; C=USER/DISK NUMBER (SEE LOC 4)
	RRA			; EXTRACT USER NUMBER
	RRA
	RRA
	RRA
	AND	#0x0F
	LD	E,A		; SET USER NUMBER
	CALL	SETUSR
	CALL	RESET		; RESET DISK SYSTEM
	POP	BC
	LD	A,C		; C=USER/DISK NUMBER (SEE LOC 4)
	AND	#0x0F		; EXTRACT DEFAULT DISK DRIVE
	LD	(TDRIVE),A	; SET IT
	CALL	LOGIN		; LOG IN DEFAULT DISK
	LD	DE,#SUBFCB	; CHECK FOR $$$.SUB ON CURRENT DISK
	CALL	SEAR1
	CPL			; 0FFH IS RETURNED IF NO $$$.SUB, SO COMPLEMENT
	LD	(RNGSUB),A	; SET FLAG (0=NO $$$.SUB)
	LD	A,(CBUFF)	; EXECUTE DEFAULT COMMAND?
	OR	A		; 0=NO
	JR	NZ,RS1
 
;*  PROMPT USER AND INPUT COMMAND LINE FROM HIM
RESTRT:
	LD	SP, #STACK	; RESET STACK
 
;*  PRINT PROMPT (DU>)
	CALL	CRLF		; PRINT PROMPT
	CALL	GETDRV		; CURRENT DRIVE IS PART OF PROMPT
	ADD	A,#"A"		; CONVERT TO ASCII A-P
	CALL	CONOUT
	CALL	GETUSR		; GET USER NUMBER
	CP	#10		; USER < 10?
	JR	C,RS00
	SUB	#10		; SUBTRACT 10 FROM IT
	PUSH	AF		; SAVE IT
	LD	A,#"1"		; OUTPUT 10'S DIGIT
	CALL	CONOUT
	POP	AF
RS00:
	ADD	A,#"0"		; OUTPUT 1'S DIGIT (CONVERT TO ASCII)
	CALL	CONOUT
 
;*  READ INPUT LINE FROM USER OR $$$.SUB
	CALL	REDBUF		; INPUT COMMAND LINE FROM USER (OR $$$.SUB)
 
;*  PROCESS INPUT LINE
RS1:
	LD	DE,#TBUFF	; PT TO INPUT COMMAND LINE (IN TBUFF)
	CALL	DMASET		; SET TBUFF TO DMA ADDRESS
	CALL	GETDRV		; GET DEFAULT DRIVE NUMBER
	LD	(TDRIVE),A	; SET IT
	CALL	SCANNER		; PARSE COMMAND NAME FROM COMMAND LINE
	CALL	NZ,ERROR	; ERROR IF COMMAND NAME CONTAINS A '?'
	LD	A,(TEMPDR)	; IS COMMAND OF FORM 'D:COMMAND'?
	OR	A		; NZ=YES
	JP	NZ,COM		; PROCESS AS COM FILE IMMEDIATELY
	CALL	CMDSER		; SCAN FOR CCP-RESIDENT COMMAND

	LD	HL,#REQTBL	; EXECUTE COMMAND (CCP-RESIDENT OR COM)
	LD	E,A		; COMPUTE OFFSET INTO ADDRESS TABLE
	LD	D,#0
	ADD	HL,DE
	ADD	HL,DE
	LD	A,(HL)		; GET ADDRESS IN HL
	INC	HL
	LD	H,(HL)		; ADDRESS HIGH
	LD	L,A		; ADDRESS LOW
	JP	(HL)		; EXECUTE CCP ROUTINE
 
;*
;*  ERROR MESSAGES
;*
PRNNF:
	CALL	PRINT		; NO FILE MESSAGE
	.asciz	'No Files'
	RET
 
;*
;*  MORE CCP UTILITIES
;*
 
;*  EXTRACT NUMBER FROM COMMAND LINE
NUMBER:
	CALL	SCANNER		; PARSE NUMBER AND PLACE IN FCBFN
	LD	A,(TEMPDR)	; TOKEN BEGIN WITH DRIVE SPEC (D:)?
	OR	A		; ERROR IF SO
	JP	NZ,ERROR
	LD	HL,#FCBFN		; PT TO TOKEN FOR CONVERSION
	LD	BC,#11		; B=ACCUMULATED VALUE, C=CHAR COUNT
NUM1:
	LD	A,(HL)		; GET CHAR
	CP	#" "		; DONE IF <SP>
	JR	Z,NUM2
	INC	HL		; PT TO NEXT CHAR
	SUB	#"0"		; CONVERT TO BINARY (ASCII 0-9 TO BINARY)
	CP	#10		; ERROR IF >= 10
	JP	NC,ERROR
	LD	D,A		; DIGIT IN D
	LD	A,B		; GET ACCUMULATED VALUE
	AND	#0xE0		; CHECK FOR RANGE ERROR (>255)
	JP	NZ,ERROR
	LD	A,B		; NEW VALUE = OLD VALUE * 10
	RLCA
	RLCA
	RLCA
	ADD	A,B		; CHECK FOR RANGE ERROR
	JP	C,ERROR
	ADD	A,B		; CHECK FOR RANGE ERROR
	JP	C,ERROR
	ADD	A,D		; NEW VALUE = OLD VALUE * 10 + DIGIT
	JP	C,ERROR		; CHECK FOR RANGE ERROR
	LD	B,A		; SET NEW VALUE
	DEC	C		; COUNT DOWN
	JR	NZ,NUM1
	RET
 
;*  REST OF TOKEN BUFFER MUST BE <SP>
NUM2:
	LD	A,(HL)		; CHECK FOR <SP>
	CP	#" "
	JP	NZ,ERROR
	INC	HL		; PT TO NEXT
	DEC	C		; COUNT DOWN CHARS
	JR	NZ,NUM2
	LD	A,B		; GET ACCUMULATED VALUE
	RET
 
;*  MOVE 3 BYTES FROM HL TO DE
MOVHD3:
	LD	B,#3		; MOVE 3 CHARS
MOVEHD:
	LD	A,(HL)		; GET IT
	LD	(DE),A		; PUT IT
	INC	HL		; PT TO NEXT
	INC	DE
	DJNZ	MOVEHD
	RET
 
;*  PT TO DIRECTORY ENTRY IN TBUFF WHOSE OFFSET IS SPECIFIED BY A AND C
DIRPTR:
	LD	HL,#TBUFF	; PT TO TEMP BUFFER
	ADD	A,C		; PT TO 1ST BYTE OF DIR ENTRY
	CALL	ADDAH		; PT TO DESIRED BYTE IN DIR ENTRY
	LD	A,(HL)		; GET DESIRED BYTE
	RET
 
;*  CHECK FOR SPECIFIED DRIVE AND LOG IT IN IF NOT DEFAULT
SLOGIN:
	XOR	A		; SET FCBDN FOR DEFAULT DRIVE
	LD	(FCBDN),A
	CALL	COMLOG		; CHECK DRIVE
	RET	Z
	JP	LOGIN		; DO LOGIN OTHERWISE
 
;*  CHECK FOR SPECIFIED DRIVE AND LOG IN DEFAULT DRIVE IF SPECIFIED<>DEFAULT
DLOGIN:
	CALL	COMLOG		; CHECK DRIVE
	RET	Z		; ABORT IF SAME
	LD	A,(TDRIVE)	; LOG IN DEFAULT DRIVE
	JP	LOGIN
 
;*  ROUTINE COMMON TO BOTH LOGIN ROUTINES; ON EXIT, Z SET MEANS ABORT
COMLOG:
	LD	A,(TEMPDR)	; DRIVE SPECIFIED?
	OR	A		; 0=NO
	RET	Z
	DEC	A		; COMPARE IT AGAINST DEFAULT
	LD	HL,#TDRIVE
	CP	(HL)
	RET			; ABORT IF SAME
 
;*
;*  CCP DIRECTORY DISPLAY FUNCTION (DIR)
;*
DIR:
	LD	A,#0x80		; SET SYSTEM BIT EXAMINATION
	PUSH	AF
	CALL	SCANNER		; EXTRACT POSSIBLE D:FILENAME.TYP TOKEN
	CALL	SLOGIN		; LOG IN DRIVE IF NECESSARY
	LD	HL,#FCBFN	; MAKE FCB WILD (ALL "?") IF NO FILENAME.TYP
	LD	A,(HL)		; GET FIRST CHAR OF FILENAME.TYP
	CP	#" "		; IF <SP>, ALL WILD
	JR	Z,DIR0
	CP	#"@"		; SYSTEM FILES?
	JR	NZ,DIR2
	INC	HL		; JUST '@'?  <SP> MUST FOLLOW
	LD	A,(HL)
	DEC	HL		; BACK UP
	CP	#" "		; JUST '@' IF <SP> FOLLOWS'
	JR	NZ,DIR2
	POP	AF		; GET FLAG
	XOR	A		; SET NO SYSTEM BIT EXAMINATION
	PUSH	AF
DIR0:
	LD	B,#11		; NUMBER OF CHARS IN FN & FT
DIR1:
	LD	(HL),#"?"	; STORE '?'
	INC	HL
	DJNZ	DIR1
DIR2:
	POP	AF		; GET FLAG
	CALL	DIRPR		; PRINT DIRECTORY
	JP	RSTCCP		; RESTART CCP
 
;*  DIRECTORY PRINT ROUTINE; ON ENTRY, MSB OF A IS 1 (80H) IF SYSTEM FILES EXCL
DIRPR:
	LD	D,A		; STORE SYSTEM FLAG IN D
	LD	E,#0		; SET COLUMN COUNTER TO ZERO
	PUSH	DE		; SAVE COLUMN COUNTER (E) AND SYSTEM FLAG (D)
	CALL	SEARF		; BDOS 17, SEARCH FOR FIRST
	CALL	Z,PRNNF		; PRINT NO FILE MSG; REG A NOT CHANGED
 
;*  ENTRY SELECTION LOOP; ON ENTRY, A=OFFSET FROM SEARF OR SEARN
DIR3:
	JR	Z,DIR11		; DONE IF ZERO FLAG SET
	DEC	A		; ADJUST TO RETURNED VALUE
	RRCA			; CONVERT NUMBER TO OFFSET INTO TBUFF
	RRCA
	RRCA
	AND	#0x60
	LD	C,A		; OFFSET INTO TBUFF IN C (C=OFFSET TO ENTRY)
	LD	A,#10		; ADD 10 TO PT TO SYSTEM FILE ATTRIBUTE BIT
	CALL	DIRPTR
	POP	DE		; GET SYSTEM BIT MASK FROM D
	PUSH	DE
	AND	D		; MASK FOR SYSTEM BIT
	JR	NZ,DIR10	; SKIP ENTRY IF BIT IS SET
	POP	DE		; GET ENTRY COUNT (=<CR> COUNTER)
	LD	A,E		; ADD 1 TO IT
	INC	E
	PUSH	DE		; SAVE IT

	AND	#1		; OUTPUT <CRLF> IF 4 ENTRIES PRINTED IN LINE

;	CP	#3
;	JR	Z, DIR3B
;	XOR	A
;DIR3B:
;	OR	A

	;0123456789012345678901234567890123456789
	;COMMAND2.COM  COMMAND2.COM  COMMAND2.COM

	PUSH	AF		; <<<<< SSSSSSSS
	JR	NZ,DIR4
	CALL	CRLF		; NEW LINE
	JR	DIR5
DIR4:
	CALL	SPACER		; PRINT <SP>:<SP> BETWEEN ENTRIES
	LD	A, #":"
	CALL	CONOUT
	CALL	SPACER
DIR5:

	LD	B,#1		; PT TO 1ST BYTE OF FILE NAME
DIR6:
	LD	A,B		; A=OFFSET
	CALL	DIRPTR		; HL NOW PTS TO 1ST BYTE OF FILE NAME
	AND	#0x7F		; MASK OUT MSB
	CP	#" "		; NO FILE NAME?
	JR	NZ,DIR8		; PRINT FILE NAME IF PRESENT
	POP	AF		; <<<<< EEEEEEEE


	PUSH	AF		; <<<<< SSSSSSSS
	CP	#3
	JR	NZ,DIR7
	LD	A,#9		; PT TO 1ST BYTE OF FILE TYPE
	CALL	DIRPTR		; HL NOW PTS TO 1ST BYTE OF FILE TYPE
	AND	#0x7F		; MASK OUT MSB
	CP	#" "		; NO FILE TYPE?
	JR	Z,DIR9		; CONTINUE IF SO
DIR7:
	LD	A,#" "		; OUTPUT <SP>
DIR8:
	CALL	CONOUT		; PRINT CHAR
	INC	B		; INCR CHAR COUNT
	LD	A,B
	CP	#12		; END OF FILENAME.TYP?
	JR	NC,DIR9		; CONTINUE IF SO
	CP	#9		; END IF FILENAME ONLY?
	JR	NZ,DIR6		; PRINT TYP IF SO
	LD	A,#"."		; PRINT DOT BETWEEN FILE NAME AND TYPE
	CALL	CONOUT
	JR	DIR6
DIR9:
	POP	AF
DIR10:
	CALL	BREAK		; CHECK FOR ABORT
	JR	NZ,DIR11
	CALL	SEARN		; SEARCH FOR NEXT FILE
	JR	DIR3
DIR11:
	POP	DE		; RESTORE STACK
	RET
 
;*
;*  CCP FILE ERASE FUNCTION (ERA)
;*
ERA:
	CALL	SCANNER		; PARSE FILE SPECIFICATION
	CP	#0xB		; ALL WILD (ALL FILES = 11 '?')?
	JR	NZ,ERA1		; IF NOT, THEN DO ERASES
	CALL	PRINT
	.asciz	'All (Y/N)?'

	CALL	REDBUF		; GET REPLY
	LD	HL,#CBUFF		; CHECK FOR <CR>
	DEC	(HL)
	JP	NZ,RESTRT		; RESTART CCP IF JUST <CR>
	INC	HL		; PT TO RESPONSE BYTE
	LD	A,(HL)		; GET IT
	CP	#"Y"		; YES?
	JP	NZ,RESTRT		; RESTART CCP IF NOT
	INC	HL		; PT TO CHAR AFTER 'Y'
	LD	(CIBPTR),HL	; SET PTR TO IT
ERA1:
	CALL	SLOGIN		; LOG IN SELECTED DISK IF ANY
	LD	A,#0x80		; SKIP SYSTEM FILES (EXAMINE SYSTEM BIT)
	CALL	DIRPR		; PRINT DIRECTORY OF ERASED FILES
	LD	DE,#FCBDN		; DELETE FILE SPECIFIED
	CALL	DELETE
	JP	RSTCCP		; REENTER CCP
 
;*
;*  CCP LIST FUNCTION (LIST)
;*
LIST:
	LD	A,#0xFF		; TURN ON PRINTER FLAG
	JR	TYPE0
 
;*
;*  CCP TYPE FUNCTION (TYPE)
;*
TYPE:
	XOR	A		; TURN OFF PRINTER FLAG
 
;*  ENTRY POINT FOR CCP LIST FUNCTION (LIST)
TYPE0:
	LD	(PRFLG),A	; SET FLAG
	CALL	SCANNER		; EXTRACT FILENAME.TYP TOKEN
	JP	NZ,ERROR	; ERROR IF ANY QUESTION MARKS
	CALL	SLOGIN		; LOG IN SELECTED DISK IF ANY
	CALL	OPENF		; OPEN SELECTED FILE
	JP	Z,TYPE4		; ABORT IF ERROR
	CALL	CRLF		; NEW LINE
	CALL	PAGSET		; SET LINE COUNT
	LD	HL,#CHRCNT	; SET CHAR POSITION/COUNT
	LD	(HL),#0xFF	; EMPTY LINE
	LD	B,#0		; SET TAB CHAR COUNTER
TYPE1:
	LD	HL,#CHRCNT	; PT TO CHAR POSITION/COUNT
	LD	A,(HL)		; END OF BUFFER?
	CP	#0x80
	JR	C,TYPE2
	PUSH	HL		; READ NEXT BLOCK
	CALL	READF
	POP	HL
	JR	NZ,TYPE3	; ERROR?
	XOR	A		; RESET COUNT
	LD	(HL),A
TYPE2:
	INC	(HL)		; INCREMENT CHAR COUNT
	LD	HL,#TBUFF	; PT TO BUFFER
	CALL	ADDAH		; COMPUTE ADDRESS OF NEXT CHAR FROM OFFSET
	LD	A,(HL)		; GET NEXT CHAR
	AND	#0x7F		; MASK OUT MSB
	CP	#0x1A		; END OF FILE (^Z)?
	JP	Z,RSTCCP	; RESTART CCP IF SO
	PUSH	AF		; SAVE CHAR
	LD	A,(PRFLG)	; TYPE OR LIST?
	OR	A		; 0=TYPE
	JR	Z,TYPE2T
 
;*  OUTPUT CHAR TO LST: DEVICE WITH TABULATION
	POP	AF		; GET CHAR
	CP	#CR		; RESET TAB COUNT?
	JR	Z,TABRST
	CP	#LF		; RESET TAB COUNT?
	JR	Z,TABRST
	CP	#TAB		; TAB?
	JR	Z,LTAB
	CALL	LSTOUT		; LIST CHAR
	INC	B		; INCREMENT CHAR COUNT
	JR	TYPE2L
TABRST:
	CALL	LSTOUT		; OUTPUT <CR>
	LD	B,#0		; RESET TAB COUNTER
	JR	TYPE2L
LTAB:
	LD	A,#" "		; <SP>
	CALL	LSTOUT
	INC	B		; INCR POS COUNT
	LD	A,B
	AND	#7
	JR	NZ,LTAB
	JR	TYPE2L
 
;*  OUTPUT CHAR TO CON: WITH TABULATION
TYPE2T:
	POP	AF		; GET CHAR
	PUSH	AF		; SAVE CHAR
	CALL	CONOUT		; TYPE CHAR
	POP	AF
	CP	#LF		; PAGE ON <LF>
	CALL	Z,PAGER		; COUNT LINES AND PAGE
 
;*  CONTINUE PROCESSING
TYPE2L:
	CALL	BREAK		; CHECK FOR ABORT
	JR	Z,TYPE1		; CONTINUE IF NO CHAR
	CP	#"C"-"@"		; ^C?
	JP	Z,RSTCCP	; RESTART IF SO
	JR	TYPE1
TYPE3:
	DEC	A		; NO ERROR?
	JP	Z,RSTCCP	; RESTART CCP
	CALL	PRINT		; PRINT READ ERROR MSG
	.asciz	'Read Error'
TYPE4:
	CALL	DLOGIN		; LOG IN DEFAULT DRIVE
	JP	ERROR
 
;*
;*  PAGING ROUTINES
;*    PAGER COUNTS DOWN LINES AND PAUSES FOR INPUT (DIRECT) IF COUNT EXPIRES
;*    PAGSET SETS LINES/PAGE COUNT
;*
PAGER:
	LD	A,(PAGCNT)	; COUNT DOWN
	DEC	A
	LD	(PAGCNT),A
	RET	NZ
	PUSH	HL		; SAVE HL
PAGER1:
	LD	C,#6		; DIRECT CONSOLE I/O
	LD	E,#0xFF		; INPUT
	CALL	BDOSB
	OR	A		; CHAR READY?
	JR	Z,PAGER1	; WAIT FOR CHAR
	CP	#"C"-"@"		; ^C
	JP	Z,RSTCCP	; RESTART CCP
	POP	HL		; RESTORE HL
PAGSET:
	LD	A,#NLINES-2	; GET LINE COUNT
	LD	(PAGCNT),A
	RET
 
;*
;*  CCP SAVE FUNCTION (SAVE)
;*
SAVE:
	CALL	NUMBER		; EXTRACT NUMBER FROM COMMAND LINE
	PUSH	AF		; SAVE IT
	CALL	SCANNER		; EXTRACT FILENAME.TYPE
	JP	NZ,ERROR	; MUST BE NO '?' IN IT
	CALL	SLOGIN		; LOG IN SELECTED DISK
	LD	DE,#FCBDN	; DELETE FILE IN CASE IT ALREADY EXISTS
	PUSH	DE
	CALL	DELETE
	POP	DE
	CALL	CREATE		; MAKE NEW FILE
	JR	Z,SAVE3		; ERROR?
	XOR	A		; SET RECORD COUNT FIELD OF NEW FILE'S FCB
	LD	(FCBCR),A
	POP	AF		; GET PAGE COUNT
	LD	L,A		; HL=PAGE COUNT
	LD	H,#0
	ADD	HL,HL		; DOUBLE IT FOR HL=SECTOR (128 BYTES) COUNT
	LD	DE,#TPA		; PT TO START OF SAVE AREA (TPA)
SAVE1:
	LD	A,H		; DONE WITH SAVE?
	OR	L		; HL=0 IF SO
	JR	Z,SAVE2
	DEC	HL		; COUNT DOWN ON SECTORS
	PUSH	HL		; SAVE PTR TO BLOCK TO SAVE
	LD	HL,#128		; 128 BYTES PER SECTOR
	ADD	HL,DE		; PT TO NEXT SECTOR
	PUSH	HL		; SAVE ON STACK
	CALL	DMASET		; SET DMA ADDRESS FOR WRITE (ADDRESS IN DE)
	LD	DE,#FCBDN	; WRITE SECTOR
	CALL	WRITE
	POP	DE		; GET PTR TO NEXT SECTOR IN DE
	POP	HL		; GET SECTOR COUNT
	JR	NZ,SAVE3	; WRITE ERROR?
	JR	SAVE1		; CONTINUE
SAVE2:
	LD	DE,#FCBDN	; CLOSE SAVED FILE
	CALL	CLOSE
	INC	A		; ERROR?
	JR	NZ,SAVE4
SAVE3:
	CALL	PRINT
	.asciz	'No Space'
SAVE4:
	CALL	DEFDMA		; SET DMA TO 0080
	JP	RSTCCP		; RESTART CCP
 
;*
;*  CCP RENAME FILE FUNCTION (REN)
;*
REN:
	CALL	SCANNER		; EXTRACT FILE NAME
	JP	NZ,ERROR	; ERROR IF ANY '?' IN IT
	LD	A,(TEMPDR)	; SAVE CURRENT DEFAULT DISK
	PUSH	AF
	CALL	SLOGIN		; LOG IN SELECTED DISK
	CALL	SEARF		; LOOK FOR SPECIFIED FILE
	JR	Z,REN0		; CONTINUE IF NOT FOUND
	CALL	PRINT
	.asciz	'File Exists'
	JP	RENRET
REN0:
	LD	HL,#FCBDN	; SAVE NEW FILE NAME
	LD	DE,#FCBDM
	LD	B,#16		; 16 BYTES
	CALL	MOVEHD
	LD	HL,(CIBPTR)	; GET PTR TO NEXT CHAR IN COMMAND LINE
	EX	DE,HL		; ... IN DE
	CALL	SBLANK		; SKIP TO NON-BLANK
	CP	#"="		; '=' OR UNDERSCORE OK
	JR	Z,REN1
	CP	#0x5F
	JR	NZ,REN4
REN1:
	EX	DE,HL		; PT TO CHAR AFTER '=' OR UNDERSCORE IN HL
	INC	HL
	LD	(CIBPTR),HL	; SAVE PTR TO OLD FILE NAME
	CALL	SCANNER		; EXTRACT FILENAME.TYP TOKEN
	JR	NZ,REN4		; ERROR IF ANY '?'
	POP	AF		; GET OLD DEFAULT DRIVE
	LD	B,A		; SAVE IT
	LD	HL,#TEMPDR	; COMPARE IT AGAINST CURRENT DEFAULT DRIVE
	LD	A,(HL)		; MATCH?
	OR	A
	JR	Z,REN2
	CP	B		; CHECK FOR DRIVE ERROR
	LD	(HL),B
	JR	NZ,REN4
REN2:
	LD	(HL),B
	XOR	A
	LD	(FCBDN),A	; SET DEFAULT DRIVE
	LD	DE,#FCBDN	; RENAME FILE
	LD	C,#0x17		; BDOS RENAME FCT
	CALL	BDOS
	INC	A		; ERROR? -- FILE NOT FOUND IF SO
	JR	NZ,RENRET
REN3:
	CALL	PRNNF		; PRINT NO FILE MSG
RENRET:
	JP	RSTCCP		; RESTART CCP
REN4:
	CALL	DLOGIN		; LOG IN DEFAULT DRIVE
	JP	ERROR
 
;*
;*  CCP SET USER NUMBER FUNCTION
;*
MAXUSR	= 15		; MAXIMUM USER AREA ACCESSABLE
USER:
	CALL	NUMBER		; EXTRACT USER NUMBER FROM COMMAND LINE
	CP	#MAXUSR+1	; ERROR IF >= MAXUSR
	JP	NC,ERROR
	LD	E,A		; PLACE USER NUMBER IN E
	LD	A,(FCBFN)	; CHECK FOR PARSE ERROR
	CP	#" "		; <SP>=ERROR
	JP	Z,ERROR
	CALL	SETUSR		; SET SPECIFIED USER
	JP	RCCPNL		; RESTART CCP (NO DEFAULT LOGIN)
 
;*
;*  CLEAR SCREEN ROUTINE FOR CRT TERMINAL
;*
CLS:
.if	H19==TRUE	; CLEAR H19/H89 CRT SCREEN
	LD	A,#ESC		; GET ESCAPE CHAR
	CALL	CONOUT
	LD	A,#"E"		; CLEAR SCREEN
	CALL	CONOUT
.endif
.if	HAZE==TRUE	; CLEAR HAZELTINE 1500 SCREEN
	LD	A,#0x7E		; TILDA PREFIX
	CALL	CONOUT
	LD	A,#28		; CLEAR SCREEN
	CALL	CONOUT
.endif
.if	FFTERM==TRUE
	LD	A,#FF
	CALL	CONOUT
.endif
	JP	RCCPNL		; RESTART CCP (NO DEFAULT LOGIN)
 
;*
;*  NOT CCP-RESIDENT COMMAND -- PROCESS AS TRANSCIENT
;*
COM:
	CALL	GETUSR		; GET CURRENT USER NUMBER
	LD	(TMPUSR),A	; SAVE IT FOR LATER
	LD	(TSELUSR),A 	; TEMP USER TO SELECT
	LD	A,(FCBFN)	; ANY COMMAND?
	CP	#" "		; " " MEANS COMMAND WAS 'D:' TO SWITCH
	JR	NZ,COM1		; NOT <SP>, SO MUST BE TRANSCIENT OR ERROR
	LD	A,(TEMPDR)	; LOOK FOR DRIVE SPEC
	OR	A		; IF ZERO, JUST BLANK
	JP	Z,RCCPNL
	DEC	A		; ADJUST FOR LOG IN
	LD	(TDRIVE),A	; SET DEFAULT DRIVE
	CALL	SETU0D		; SET DRIVE WITH USER 0
	CALL	LOGIN		; LOG IN DRIVE
	JP	RCCPNL		; RESTART CCP
COM1:
	LD	A,(FCBFT)	; CHECK FOR ERROR IN FCB
	CP	#" "		; ERROR IF SO
	JP	NZ,ERROR
;*
;*  COMA IS A REENTRY POINT FOR A NON-STANDARD CP/M MODIFICATION
;* THIS IS THE RETURN POINT FOR WHEN THE .COM FILE IS NOT FOUND THE
;* FIRST TIME, DRIVE A: IS SELECTED FOR A SECOND STTEMPT
;*
COMA:
	CALL	SLOGIN		; LOG IN SPECIFIED DRIVE IF ANY
	LD	HL,#COMMSG	; PLACE 'COM' IN FCB
	LD	DE,#FCBFT 	; PT TO FILE TYPE
	CALL	MOVHD3		; MOVE 3 CHARS
	CALL	OPENF		; OPEN COMMAND.COM FILE
	JR	NZ,COMA1	; ERROR?
 
;*  ERROR ROUTINE TO SELECT USER 0 IF ALL ELSE FAILS
	LD	A,(TSELUSR) 	; GET USER FLAG
	OR	A		; SET FLAGS
	JR	Z,COMA0		; TRY DISK A: IF ALREADY USER 0
	XOR	A		; SELECT USER 0
	LD	E,A
	LD	(TSELUSR),A 	; RESET TEMPORARY USER NUMBER
	CALL	SETUSR
	JR	COMA		; TRY AGAIN
 
;*  ERROR ROUTINE TO SELECT DRIVE A: IF DEFAULT WAS ORIGINALLY SELECTED
COMA0:
	LD	HL,#TEMPDR	; GET DRIVE FROM CURRENT COMMAND
	XOR	A		; A=0
	OR	(HL)
	JP	NZ,COM8		; ERROR IF ALREADY DISK A:
	LD	(HL),#1		; SELECT DRIVE A:
	JR	COMA
 
;*  FILE FOUND -- PROCEED WITH LOAD
COMA1:
	LD	HL,#TPA		; SET START ADDRESS OF MEMORY LOAD
COM2:
	PUSH	HL		; SAVE ADDRESS OF NEXT SECTOR
	EX	DE,HL		; ... IN DE
	CALL	DMASET		; SET DMA ADDRESS FOR LOAD
	LD	DE,#FCBDN	; READ NEXT SECTOR
	CALL	READ
	JR	NZ,COM3		; READ ERROR OR EOF?
	POP	HL		; GET ADDRESS OF NEXT SECTOR
	LD	DE,#128		; MOVE 128 BYTES PER SECTOR
	ADD	HL,DE		; PT TO NEXT SECTOR IN HL
	LD	DE,#ENTRY-128	; ARE WE GOING TO WRITE OVER CCP?
	LD	A,L		; COMPARE ADDRESS OF NEXT SECTOR (HL)
	SUB	E		;   TO START OF CCP (DE)
	LD	A,H
	SBC	A,D
	JR	NC,PRNLE	; ERROR IF SAME
	JR	COM2		; OTHERWISE CONTINUE

;*  LOAD ERROR
PRNLE:
	CALL	PRINT
	.asciz	'Bad Load'
	JP	RSTCCP
 
COM3:
	POP	HL		; LOAD COMPLETE!
	DEC	A
	JR	NZ,PRNLE
	CALL	RESETUSR	; RESET CURRENT USER NUMBER
				;   USER MUST BE SET BEFORE LOGIN IS DONE
	CALL	DLOGIN		; LOG IN DEFAULT DRIVE
	CALL	SCANNER		; SEARCH COMMAND LINE FOR NEXT TOKEN
	LD	HL,#TEMPDR	; SAVE PTR TO DRIVE SPEC
	PUSH	HL
	LD	A,(HL)		; SET DRIVE SPEC
	LD	(FCBDN),A
	LD	A,#0x10		; OFFSET FOR 2ND FILE SPEC
	CALL	SCAN1		; SCAN FOR IT AND LOAD IT INTO FCBDN+16
	POP	HL		; SET UP DRIVE SPECS
	LD	A,(HL)
	LD	(FCBDM),A
	XOR	A
	LD	(FCBCR),A
	LD	DE,#TFCB		; COPY TO DEFAULT FCB
	LD	HL,#FCBDN		; FROM FCBDN
	LD	B,#33		; SET UP DEFAULT FCB
	CALL	MOVEHD
	LD	HL,#CIBUFF
COM4:
	LD	A,(HL)		; SKIP TO END OF 2ND FILE NAME
	OR	A		; END OF LINE?
	JR	Z,COM5
	CP	#" "		; END OF TOKEN?
	JR	Z,COM5
	INC	HL
	JR	COM4
 
;*  LOAD COMMAND LINE INTO TBUFF
COM5:
	LD	B,#0		; SET CHAR COUNT
	LD	DE,#TBUFF+1	; PT TO CHAR POS
COM6:
	LD	A,(HL)		; COPY COMMAND LINE TO TBUFF
	LD	(DE),A
	OR	A		; DONE IF ZERO
	JR	Z,COM7
	INC	B		; INCR CHAR COUNT
	INC	HL		; PT TO NEXT
	INC	DE
	JR	COM6
 
;*  RUN LOADED TRANSCIENT PROGRAM
COM7:
	LD	A,B		; SAVE CHAR COUNT
	LD	(TBUFF),A
	CALL	CRLF		; NEW LINE
	CALL	DEFDMA		; SET DMA TO 0080
	CALL	SETUD		; SET USER/DISK
	CALL	TPA		; RUN TRANSCIENT
	CALL	SETU0D		; SET USER 0/DISK
	CALL	LOGIN		; LOGIN DISK
	JP	RESTRT		; RESTART CCP
 
;*  TRANSCIENT LOAD ERROR
COM8:
	CALL	RESETUSR	; RESET CURRENT USER NUMBER
				;   RESET MUST BE DONE BEFORE LOGIN
	CALL	DLOGIN		; LOG IN DEFAULT DISK
	JP	ERROR
 
;*  RESET SELECTED USER NUMBER IF CHANGED
RESETUSR:
	LD	A,(TMPUSR)	; GET OLD USER NUMBER
	LD	E,A		; PLACE IN E
	JP	SETUSR		; RESET
 
;*  FILE TYPE FOR COMMAND
COMMSG:
	.ascii	'COM'
 
;*  ENTRY POINT FOR RESTARTING CCP AND LOGGING IN DEFAULT DRIVE
RSTCCP:
	CALL	DLOGIN		; LOG IN DEFAULT DRIVE
;*  ENTRY POINT FOR RESTARTING CCP WITHOUT LOGGING IN DEFAULT DRIVE
RCCPNL:
	CALL	SCANNER		; EXTRACT NEXT TOKEN FROM COMMAND LINE
	LD	A,(FCBFN)	; GET FIRST CHAR OF TOKEN
	SUB	#" "		; ANY CHAR?
	LD	HL,#TEMPDR
	OR	(HL)
	JP	NZ,ERROR
	JP	RESTRT
 
 
RNGSUB:
	.DB	0		;0=$$$.SUB NOT PRESENT, ELSE $$$.SUB PRESENT
 
;*
;*  FILE CONTROL BLOCK (FCB), ONE
;*
SUBFCB:
	.DB	1		;DISK NAME
	.ascii	'$$$'		;FILE NAME
	.ascii	'     '
	.ascii	'SUB'		;FILE TYPE
	.DB	0		;EXTENT NUMBER
	.DB	0		;S1
SUBFS2:
	.DS	1		;S2
SUBFRC:
	.DS	1		;RECORD COUNT
	.DS	16		;DISK GROUP MAP
SUBFCR:
	.DS	1		;CURRENT RECORD NUMBER
 
;*
;*  FILE CONTROL BLOCK
;*
FCBDN:
	.DS	1		;DISK NAME
FCBFN:
	.DS	8		;FILE NAME
FCBFT:
	.DS	3		;FILE TYPE
	.DS	1		;EXTENT NUMBER
	.DS	2		;S1 AND S2
	.DS	1		;RECORD COUNT
FCBDM:
	.DS	16		;DISK GROUP MAP
FCBCR:
	.DS	1		;CURRENT RECORD NUMBER
 
;*  OTHER BUFFERS
PRFLG:
	.DB	0		;PRINTER FLAG (0=NO, 0FFH=YES)
PAGCNT:
	.DB	NLINES-2	;LINES LEFT ON PAGE
IORESL:
	.DB	0		;I/O RESULTS
TDRIVE:
	.DB	1		;TEMP DRIVE NUMBER
TEMPDR:
	.DB	0
CHRCNT:
	.DB	0		;CHAR COUNT FOR TYPE
TMPUSR:
	.DB	0		;TEMPORARY USER NUMBER FOR COM
TSELUSR:
	.DB	0		;TEMPORARY SELECTED USER NUMBER


;	.DB 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A
;	.DB 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A
;	.DB 0x1A, 0x1A ;, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A
