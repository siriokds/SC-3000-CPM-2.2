RAMLOW	=	0x0000			; START ADDRESS MEMORY
BDOS0 	=	0xDC00
P2BIOS	=	0xEA00

.area _HEADER (ABS)
	.ORG	BDOS0


;******************************************************************************
;*									      *
;*  P 2 D O S --Z80 REPLACEMENT DISK OPERATING SYSTEM VERSION 2.3	      *
;*		No more control-C to change disks!		              *
;*  COPYRIGHT (C) 1985 BY:	 H.A.J. TEN BRUGGE			      *
;*  ALL RIGHTS RESERVED		 MOLENSTRAAT 33				      *
;*			 	 NL-7491 BD DELDEN			      *
;*				 THE NETHERLANDS			      *
;*				 TEL:..31-5407-1980			      *
;*  P2DOS WAS WRITTEN BY HERMAN TEN BRUGGE, WHO ASSUMES NO RESPONSIBILITY     *
;*  OR LIABILITY FOR ITS USE. P2DOS IS RELEASED TO THE PUBLIC DOMAIN FOR      *
;*  NON-COMMERCIAL USE ONLY.						      *
;*									      *
;*  THE PULBLIC IS ENCOURAGED TO FREELY COPY AND USE THIS PROGRAM FOR         *
;*  NON-COMMERCIAL PURPOSES. ANY COMMERCIAL USE OF P2DOS IS PROHIBITED        *
;*  UNLESS APPROVED BY THE AUTHOR, H.A.J. TEN BRUGGE, IN WRITING.	      *
;*								              *     
;*  THIS IS MOD 2.3 TO THE RELEASE VERSION OF P2DOS			      *
;*									      *
;******************************************************************************
;*
;* Mod 2.3 Revisions
;*
;*   By Donald C. Kirkpatrick
;*      17595 S.W. Pheasant Lane
;*      Beaverton, Oregon 97006
;*      15 February 1988
;*	uucp: !tektronix!dadla!donk
;*
;*   Name returned to P2DOS.
;*
;*   Restored full compatibility with P2DOS mod 2.1 and Digital Research
;*   BDOS. Moved disk error routines and path location address back to
;*   where they were in P2DOS. Fixed Drive Reset Command 37 so only drives
;*   specified in reset vector are affected.
;*
;*   Made system file r/o an assembly time option to satisfy Benjamin Ho's
;*   desire to not protect system files yet allow those of us who want
;*   insurance to take insurance.
;*
;*   Added single character ignore read/only status. It seemed just too
;*   dangerous to allow any character except ^C to cancel r/o status.
;*   This is an assembly time option, so those who wish to retain the
;*   any character cancels r/o status may. The ignore r/o status
;*   character was chosen to be ^X (CANCEL), but may be set to anything
;*   by changing the IGNORE equate.
;*
;*   Added flag to the FLAGS byte to disable ignore r/o status so a
;*   running program can insist that the r/o status of a file or disk
;*   be observed.
;*
;*   Added an assembly time option to allow true XON (^Q) - XOFF (^S)
;*   start/stop of console output. If this option is selected, only
;*   a ^Q will restart suspended console output. Also added is an assembly
;*   time option so suspended console output cannot be restarted by
;*   ^S. It has always seemed a mistake that a second ^S would restart
;*   something suspended by ^S. If neither assembly time option is
;*   selected, console suspention will operate just as it always has.
;*
;**************************************************************************
;*
;*  MOD 2.2 Revisions (Mod 2.2 a.k.a. Mod 0.2 of SUPRBDOS)
;*  Renamed to SUPRBDOS
;*		By Benjamin Ho
;*   	 	   626 Emerson St.
;*                 Evanston, IL 60201
;*  Background:
;* 
;*  P2DOS MOD 2.1 was not a major improvement on the standard CP/M BDOS.
;*  While it added Public files, slightly more informative error messages, and
;*  time stamp support, it did not fix the major annoyances of the CP/M BDOS,
;*  namely the necessity of logging in new disks with Control-C, mystifying
;*  error messages, and a delete key that looked like it didn't delete.  
;*
;*  P2DOS MOD 2.2 is a major enhancement which liberates the CP/M user from all
;*  these annoyances.  It is compatible with all CP/M software except those
;*  that modify the BDOS.  Fortunately, that type of program is extremely rare.
;*
;*  P2DOS MOD 2.2 may be used with ZCPR3 to provide an extremely powerful
;*  100% CP/M 2.2 compatible operating system.  The resulting system is not
;*  subject to Digital Research's licensing agreement.  The only restriction
;*  is that it may be used for non-commerical use only, as stated by the
;*  authors of ZCPR3 and P2DOS.
;*
;*  Enjoy!
;*  9/2/86- 
;*	    Added automatic login of changed disks--no more Control-C 
;*	      when changing disks!  
;*	    Removed P2DOS tie to ZCPR2.  Can now be used with ZCPR3 or 
;*            (ugh!) normal CP/M.  
;*	    Improved error messages:  
;*	      Disk Error on X: Read Error 
;*                             Write Error 
;*	                       Non-existent drive 
;*                             File is Read-Only 
;*	    Fixed delete key--now works like backspace.  No echoing characters 
;*	    Allowed functions 13 and 37 to recognize changes between single and 
;*            double sided disks on machines which normally require a warm 
;*            boot when "sidedness" is changed.  Bios modification is needed 
;*            to support this feature 
;*	    Fixed directory read bug.  Function 37 bug which plagued
;*            library utility program NULU 1.5 is fixed.				
;*	    Choice of assembly by M80 and compatibles or public domain ZASM 
;*          System files are read/write, as in CP/M.  Changed from P2DOS 
;*           mod 2.1 in which system files were R/O
;*          Deleted P2DOS search path so the more flexible 
;*           ZCR3 search path could be used
;*          File split into 3 sections for easy of editing.
;******************************************************************************
;
;
;
;  P 2 D O S --Z80 REPLACEMENT DISK OPERATING SYSTEM VERSION 2.3
;
;
; NEW FEATURES OF P2DOS ARE:
;
; - TEST CONSOLE STATUS AFTER 256 CHARACTERS OUTPUT. THIS MAKES IT POSSIBLE TO
;   EXIT A PROGRAM, AFTER YOU HIT ACCIDENTALY A KEY, BY TYPING ^S FOLLOWED
;   BY ^C. THIS FIXES A BUG IN THE DIGITAL RESEARCH BDOS. THERE, ANY OTHER
;   CHARACTER WOULD CAUSE ALL SUBSEQUENT ^S TO BE IGNORED.
;
; - ERROR ROUTINES GIVE MORE INFORMATION.
;      P2DOS ERROR ON D: BAD SECTOR
;			 SELECT
;			 FILE R/O
;			 R/O
;      FUNCTION =XXX (FILE =FILENAME.TYP)
;   AS YOU CAN SEE THE ERROR IS DISPLAYED WITH THE P2DOS FUNCTION CALL.
;   THE OPTION 'FILE =FILENAME.TYP' IS ONLY DISPLAYED IF THE P2DOS FUNCTION
;   USES A FILENAME. AFTER ALL ERRORS A WARM BOOT IS DONE.
;
; - PUBLIC FILES ARE SUPPORTED. YOU CAN ACCESS A PUBLIC FILE FROM ANY
;   USER NUMBER.  THIS MAKES IT POSSIBLE TO PUT FOR EXAMPLE ALL '.COM' IN 
;   A SPECIAL USER NUMBER AND MAKE ALL THOSE FILES PUBLIC. YOU CAN ACCESS ALL 
;   THE FILES FROM ANY USER NUMBER ON THE SAME DISK.
;   A PUBLIC FILE IS A FILE WITH BIT F2 (BIT 7 FROM FILENAME LETTER 2) SET TO
;   ONE. PUBLIC FILES CAN ONLY BE REFERENCED BY THERE EXACT NAME AND NOT BY WILD
;   CARD CHARACTERS. 
;
; - SEARCH PATH IS IMPLEMENTED JUST AS IN ZCPR2 TO FIND FILES ON OTHER DRIVES
;   AND IN OTHER USER AREAS. THE FILES MUST BE SYSTEM FILES AND MUST BE
;   REFERENCED BY THEIR EXACT NAME AS IN PUBLIC FILE NAMES ABOVE.
;
; - AUTOMATIC DATE AND TIME STAMP IS IMPLEMENTED. THE CREATION DATE AND TIME
;   IS SET WHEN THE FUNCTION MAKE IS EXECUTED. THE UPDATE DATE AND TIME IS
;   SET AS THE FILE IS CLOSED. TO LET THIS FEATURE WORK YOU NEED TO HAVE A 
;   REAL TIME CLOCK AND THE CORRECT P2BIOS DRIVER ROUTINE. YOU ALSO HAVE TO 
;   INITIALISE YOUR  DIRECTORY FOR TIME STAMPS.   
;
; - FILE R/O ERROR MESSAGE OCCURS IF ONE OF THE FOLLOWING FILE TYPES IS ACTIVE:
;     PUBLIC FILE (F2)
;     FILE R/O    (T1)
;     SYSTEM FILE (T2) (if enabled)
;   THIS MEANS THAT A SYSTEM FILE OR PUBLIC FILE CANNOT BE ERASED ACCIDENTALY.
;
; - NEW FUNCTION GET TIME (200) IS IMPLEMENTED TO GET THE CORRECT DATE AND TIME.
;   ENTRY DE IS ADDRESS TO PUT TIME. THE DATE AND TIME RECORD HAS THE FOLLOWING
;   LAYOUT:
;	DATE:	DEFS	2	DATE = 1     (SU 01-JAN-1978)
;				DATE = 65535 (SU 05-JUN-2157) 	
;	HOUR:	DEFS	1	HOUR IN BCD
;	MINUTE:	DEFS	1	MINUTE IN BCD
;	SECOND:	DEFS	1	SECOND IN BCD
;    FUNCTION WORKS ONLY IF CORRECT P2BIOS FUNCTION CALL IS INSTALLED.
;
; - NEW FUNCTION SET TIME (201) IS IMPLEMENTED TO SET THE CORRECT DATE AND TIME.
;   ENTRY DE IS ADDRESS NEW TIME. THE DATE AND TIME LAYOUT IS AS ABOVE.
;   FUNCTION WORKS ONLY IF CORRECT P2BIOS FUNCTION CALL IS INSTALLED.
;
;  * DISK SIZE CAN BE AS LARGE AS 65536*16K=1 048 576 K BYTE=1 G BYTE. 
;  * FILE SIZE CAN BE AS LARGE AS 32*64*16K=32 768K BYTE=32 M BYTE.  
;
;
; YOU CAN ENABLE/DISABLE THE FUNCTIONS MENTIONED ABOVE WITH THE FOLLOWING
; DATA AND ADDRESSES.
;
; - ENABLE PATH NAME BY PUTTING ADDRESS OF PATH IN P2DOS+11H. IF THIS VALUE IS
;   0000H NO PATH IS USED. THIS ADDRESS IS NORMALLY SET TO 0040H.
;
; - ENABLE P2DOS TIME AND DATE STAMP BY PUTTING THE CORRECT P2BIOS ADDRESS
;   AT P2DOS+13H. THIS ADDRESS IS NORMALY SET TO THE P2BIOS CONSOLE STATUS 
;   FUNCTION. 
;
; - YOU CAN ENABLE THE 256 CHARACTER DELAY FUNCTION BY SETTING BIT 0 OF
;   ADDRESS P2DOS+15H. THIS BIT IS NORMALLY SET TO 1.
;
; - YOU CAN ENABLE PUBLIC FILES BY SETTING BIT 1 OF ADDRESS P2DOS+15H.
;   THIS BIT IS NORMALLY SET TO 1.
;
; - YOU CAN ENABLE IGNORE R/O STATUS BY SETTING BIT 2 OF ADDRESS P2DOS+15H
;   THIS BIT IS NORMALLY SET TO 1.
;
; ENTRY ADDRESSES P2BIOS
;
; FUNC	NAME	INPUT PARAMETERS	RETURNED VALUES
;  0	BOOT	NONE			NONE
;  1	WBOOT	NONE			NONE
;  2	CONST	NONE			A=0FFH IF READY
;	 				A=000H IF NOT READY
;  3	CONIN	NONE			A=CONSOLE CHARACTER
;  4	CONOUT	C=CONSOLE CHARACTER	NONE
;  5	LIST	C=LIST CHARACTER	NONE
;  6	PUNCH	C=PUNCH CHARACTER	NONE
;  7	READER	NONE			A=READER CHARACTER
;  8	HOME	NONE			NONE
;  9	SELDSK	C=DRIVE NUMBER (0..15)	HL=DISK PARAMETER HEADER ADDRESS
;		E=INIT SELECT FLAG	HL=0000H IF INVALID DRIVE
; 10	SETTRK	BC=TRACK NUMBER		NONE
; 11	SETSEC	BC=SECTOR NUMBER	NONE
; 12	SETDMA	BC=DMA ADDRESS		NONE
; 13	READ	NONE			A=00H IF NO ERROR
;					A=01H IF ERROR
; 14	WRITE	C=0 WRITE DATA		A=00H IF NO ERROR
;		C=1 WRITE DIRECTORY	A=01H IF ERROR
;		C=2 WRITE NEW DATA
; 15	LISTST	NONE			A=000H IF READY
;					A=0FFH IF NOT READY
; 16	SECTRN	BC=LOGICAL SECTOR	HL=PHYSICAL SECTOR NUMBER
;		    NUMBER
;		DE=TRANSLATION TABLE
;		    ADDRESS
; XX	TIME	C=000H GET TIME		HL=POINTER TO TIME TABLE
;		C=0FFH UPDATE CLOCK	HL+0:DATE LSB SINCE 1,1,1978
;		HL=POINTER TO TIME	HL+1:DATE MSB
;		    TABLE		HL+2:HOURS  (BCD)
;					HL+3:MINUTES (BCD)
;					HL+4:SECONDS (BCD)
;
; XX	SETDSK	NONE			NONE
;
;
;
;
;
;
BOOT	=	P2BIOS+0x0000		; P2 SYSTEM COLD BOOT
WBOOT	=	P2BIOS+0x0003		; P2 SYSTEM WARM BOOT
CONST	=	P2BIOS+0x0006		; P2 SYSTEM CONSOLE STATUS
CONIN	=	P2BIOS+0x0009		; P2 SYSTEM CONSOLE INPUT
CONOUT	=	P2BIOS+0x000C		; P2 SYSTEM CONSOLE OUTPUT
LIST	=	P2BIOS+0x000F		; P2 SYSTEM LIST OUTPUT
PUNCH	=	P2BIOS+0x0012		; P2 SYSTEM PUNCH OUTPUT
READER	=	P2BIOS+0x0015		; P2 SYSTEM READER INPUT
HOME	=	P2BIOS+0x0018		; P2 SYSTEM HOME DISK
SELDSK	=	P2BIOS+0x001B		; P2 SYSTEM SELECT DISK
SETTRK	=	P2BIOS+0x001E		; P2 SYSTEM SELECT TRACK
SETSEC	=	P2BIOS+0x0021		; P2 SYSTEM SELECT SECTOR
SETDMA	=	P2BIOS+0x0024		; P2 SYSTEM SET DMA ADDRESS
READ	=	P2BIOS+0x0027		; P2 SYSTEM READ 128 BYTES
WRITE	=	P2BIOS+0x002A		; P2 SYSTEM WRITE 128 BYTES
LISTST	=	P2BIOS+0x002D		; P2 SYSTEM LIST STATUS
SECTRN	=	P2BIOS+0x0030		; P2 SYSTEM SECTOR TRANSLATION
TIME	=	P2BIOS+0x0033		; P2 SYSTEM GET/SET TIME
SETDSK	=	P2BIOS+0x0036		; P2 SYSTEM DISK CHANGE SENSE
;
;
; INTERNAL DEFINITIONS
;
CONTC	=	0x03			; KEY TO GENERATE WARM BOOT
CONTE	=	0x05			; BREAK LINE
CONTH	=	0x08			; BACKSPACE
TAB	=	0x09			; TAB
LF	=	0x0A			; LINE FEED
CR	=	0x0D			; CARRIAGE RETURN
SPC	=	0x20			; SPACE
SHARP	=	0x23			; SHARP = "#"
DOLLAR	=	"$"			; DOLLAR = "$"
CONTP	=	0x10			; SET/RESET PRINT FLAG
CONTQ	=	0x11			; restart console output
CONTR	=	0x12			; REPEAT LINE
CONTS	=	0x13			; STOP CONSOLE OUTPUT
CONTU	=	0x15			; DELETE LINE
CONTX	=	0x18			; DELETE LINE (BACKSPACES)
DRVSEP	=	0x3A			; DRIVE SEPERATOR (:)
RUBOUT	=	0x7F			; DELETE LAST CHAR
IGNORE	=	CONTX			; Ignore R/O status character
;
MAXCMD	=	40			; NUMBER OF VALID P2DOS COMMANDS
;
;=============================
;P2DOS Customization
;
;(Formerly a.k.a. SUPRBDOS)
;
;See INSTALL.DOC for more information on installation.
;
FALSE	=	0 
TRUE	=	0xFF
;
;
;Assembly Conditionals:
;
DOTIME	=	FALSE			; True if time stamp is supported 
;
;
;Some systems, like the Kaypro 4, only recognize changes between single 
;and double sided disks when the system is warm booted; bdos function 13 
;(reset disk) will not work.  By adding a "hook" to the bios of these 
;machines and setting RESDSK to TRUE, bdos functions 13 and 37 will 
;allowchanges between single and double sided disks.  Very handy for disk
;housekeeping utilities such as NSWP, NULU, and cataloging programs.  
;  
;The "hook" is added as follows: Obtain the source to your computer's BIOS.  
;Examine the code for WARM BOOT.  Somewhere, there should be a call to 
;a routine which initializes the disk system after a warm boot, or which 
;detects changes between single and double sided disks.  Call this routine
;DISKINT for purposes of discussion.  Modify your bios's cold boot routine to
;initialize 3 bytes at address SETDSK as "JP DISKINT".  The location of SETDSK
;is arbitrary, it may be in your bios, or in a reserved spot in CP/M's page 0.
;It is assumed here that "JP DISKINT" is in the BIOS jump table one beyond
;the jump to the time routine.
;
RESDSK	=	FALSE			; Set to true only if your drives
					; can have more than one disk format.
					; Set to false if, for example,
					; drive A only supports single
					; density disks and drive B only
					; supports double density two-sided
 					; disks. IF YOU CAN'T MIX FORMATS
					; ON THE SAME DRIVE OR YOUR BIOS
					; ALWAYS KNOWS WHAT THE PROPER
					; FORMAT IS, YOU DON'T NEED A 
					; DISKINT ROUTINE!!!!
;
PATHON	=	FALSE			; True to enable BDOS search.
					; If PATHON is set, then some code
					; must be inserted either here or in
					; the BIOS to initialize the path
					; at RAMLOW+040H
;
SYSRO	=	TRUE			; True for system files read only.
					; Since P2DOS allows the run-time
					; cancel of read-only status, this
					; is a good saftey precaution to
					; prevent accedential erasure.
;
XONOFF	=	TRUE			; True for "true" xon/xoff
					; When set, only ^S stops console
					; output and only ^Q restarts output.
;
NOXOFF	=	FALSE			; True disables ^S as a restart char
					; When set, the first ^S stops
					; console output, but subsequent
					; ^S's will not restart output.
					; XONOFF takes presedent if both
					; are true.
;
DEFFLG	=	0xFF			; Default value for flag byte.
					; set bit means:
					;  bit 0=public file enable
					;  bit 1=delay 256 char active
					;  bit 2=allow r/o ignore
; enter your serial number here
SERNO1	=	"P"
SERNO2	=	"2"
SERNO3	=	"D"
SERNO4	=	"O"
SERNO5	=	"S"
SERNO6	=	0x00
;
;
;.INCL "P2DOS1"
;
; START PROGRAM
;	

P2DOS:
SERIAL:	
	.DB	SERNO1			; serial number
	.DB	SERNO2			
	.DB	SERNO3			
	.DB	SERNO4
	.DB	SERNO5
	.DB	SERNO6


;
; START P2DOS	(THIS ADDRESS IS COPIED TO LOCATION 0x0005)
;
START:	JP	ENTRY			; JUMP TO ENTRY POINT P2DOS
;
; ERROR MESSAGES P2DOS
;
;Bad sector message changed to read/write messages-B.H.
STBDSC:	.DW	BADSEC			; split into read and write
STSEL:	.DW	SELERR			; SELECT ERROR
STRO:	.DW	RDONLY			; DRIVE READ ONLY
SFILRO:	.DW	FILRO			; FILE READ ONLY
;
; BDOS Search Path Address
;
PATH:					; keep same loc as in P2DOS
	.IF	PATHON==TRUE
	.DW	RAMLOW+0x40
	.ELSE
	.DW	0x0000
	.ENDIF
;
; TIME ADDRESS P2BIOS
;
TIMEAD:
	.IF	DOTIME==TRUE
	.DW	TIME			; TIME ROUTINE ADDRESS FOR TIME
					; AND DATE STAMPS
	.ELSE
	.DW	CONST
	.ENDIF
;
;
; FLAGS FOR SPECIALS
; BIT 0: PUBLIC FILE ENABLE(1)/DISABLE(0)
; BIT 1: DELAY 256 CHARACTERS ACTIVE(1)/DISABLE(0)
; BIT 2: WRITE PROTECT IGNORE ENABLED(1)/DISABLED(0)
;
FLAGS:	.DB	DEFFLG			; FLAG BYTE
;
; ENTRY POINT P2DOS COMMANDS
;
ENTRY:	LD	A,C			; GET FUNCTION NUMBER
	LD	(FUNCT),A		; SAVE IT FOR LATER USE
	LD	HL,#0			; SET HL TO ZERO
	LD	(PEXIT),HL		; CLEAR EXIT CODE
	XOR	A			; CLEAR A
	LD	(FLDRV),A		; RESET DRIVE SELECT DONE FLAG
	LD	(RDWR),A		; RESET READ/WRITE FLAG
	LD	(SPSAVE),SP		; SAVE STACK POINTER
	LD	SP,#P2DOSS		; GET INTERNAL STACK POINTER
	PUSH	IX			; SAVE INDEX REGISTER
	PUSH	DE			; SAVE PARAMETER REGISTER
	POP	IX			; GET IT BACK IN IX
	LD	HL,#P2EXIT		; GET EXIT ADDRESS P2DOS
	PUSH	HL			; SAVE IT ON STACK TO RETURN FROM P2DOS
	LD	A,C			; GET FUNCTION CODE
;
	.IF	DOTIME==TRUE
	CP	#200			; TEST GET TIME
	JP	Z,GETTIM		; YES THEN GET TIME
	CP	#201			; TEST SET TIME
	JP	Z,SETTIM		; YES THEN SET TIME
	.ENDIF
;
	CP	#MAXCMD+1		; TEST GREATER THEN MAXCMD 
	RET	NC			; IF SO RETURN TO CALLER AND DO NOTHING
	LD	HL,#CTABLE		; LOAD TABLE
	LD	B,#0			; PREPARE 16 BIT ADD
	ADD	HL,BC			; ADD
	ADD	HL,BC			; ADD TWICE TO GET WORD VALUE
	LD	A,(HL)			; GET LSB
	INC	HL			; POINTER TO MSB
	LD	H,(HL)			; GET MSB
	LD	L,A			; SAVE LSB IN L 
	JP	(HL)			; JUMP TO ROUTINE
;
; COMMAND TABLE
; +++
;
; FUNC	NAME			INPUT PARAMETERS	RETURNED VALUES
;   0	BOOT			NONE			NONE
;   1	CONSOLE INPUT		NONE			A=CHARACTER
;   2	CONSOLE OUTPUT		E=CHARACTER		A=00H
;   3	READER INPUT		NONE			A=CHARACTER
;   4	PUNCH OUTPUT		E=CHARACTER		A=00H
;   5	LIST OUTPUT		E=CHARACTER		A=00H
;   6	DIRECT CONSOLE I/O	E=0FFH			A=INPUT CHARACTER
;							A=00H IF NO CHARACTER 
;								PRESENT
;				E=0FEH			A=CONSOLE STATUS
;				E=000H..0FDH		A=00H
;   7	GET I/O BYTE		NONE			A=I/O BYTE (RAMLOW+03H)
;   8	SET I/O BYTE		E=I/O BYTE		A=00H
;   9	PRINT STRING		DE=ADDRESS STRING	A=00H
;  10	READ CONSOLE BUFFER	DE=ADDRESS BUFFER	A=00H
;  11	GET CONSOLE STATUS	NONE			A=00H IF NO CHARACTER 
;								PRESENT
;							01H IF CHARACTER PRESENT
;  12	RETURN VERSION NUMBER	NONE			A=VERSION NUMBER (022H)
;  13	RESET DISK SYSTEM	NONE			A=00H NO $*.* FILE
;							A=FFH $*.* FILE PRESENT
;  14	SELECT DISK		E=DISK NUMBER		A=00H
;  15	OPEN FILE		DE=ADDRESS FCB		A=DIRECTORY CODE
;  16	CLOSE FILE		DE=ADDRESS FCB		A=DIRECTORY CODE
;  17	SEARCH FOR FIRST	DE=ADDRESS FCB		A=DIRECTORY CODE
;  18	SEARCH FOR NEXT		DE=ADDRESS FCB		A=DIRECTORY CODE
;  19	DELETE FILE		DE=ADDRESS FCB		A=ERROR CODE
;  20	READ SEQUENTIAL		DE=ADDRESS FCB		A=READ/WRITE CODE
;  21	WRITE SEQUENTIAL	DE=ADDRESS FCB		A=READ/WRITE CODE
;  22	MAKE FILE		DE=ADDRESS FCB		A=DIRECTORY CODE
;  23	RENAME FILE		DE=ADDRESS FCB		A=ERROR CODE
;  24	RETURN LOGIN VECTOR	NONE			HL=LOGIN VECTOR
;  25	RETURN CURRENT DISK	NONE			A=CURRENT DISK
;  26	SET DMA ADDRESS		DE=DMA ADDRESS		A=00H
;  27	GET ALLOCATION ADDRESS	NONE			HL=ADDRESS ALLOCATION 
;								VECTOR
;  28	WRITE PROTECT DISK	NONE			A=00H
;  29	GET R/O VECTOR		NONE			HL=R/O VECTOR
;  30	SET FILE ATTRIBUTES	DE=ADDRESS FCB		A=ERROR CODE
;  31	GET ADDRESS DPB		NONE			HL=ADDRESS DPB
;  32	SET/GET USER CODE	E=0FFH			A=USER NUMBER
;				E=USER NUMBER		A=00H
;  33	READ RANDOM		DE=ADDRESS FCB		A=READ/WRITE CODE
;  34	WRITE RANDOM		DE=ADDRESS FCB		A=READ/WRITE CODE
;  35	COMPUTE FILE SIZE	DE=ADDRESS FCB		A=ERROR CODE
;  36	SET RANDOM RECORD	DE=ADDRESS FCB		A=00H
;  37	RESET MULTIPLE DRIVE	DE=MASK			A=00H NO $*.* FILE
;							A=FFH $*.* FILE PRESENT
;  38	NOT IMPLEMENTED		NONE			A=00H
;  39	NOT IMPLEMENTED		NONE			A=00H
;  40	WRITE RANDOM WITH	DE=ADDRESS FCB		A=READ/WRITE CODE
;	 ZERO FILL
; 200	GET TIME		DE=ADDRESS TO PUT TIME	A=00H
; 201	SET TIME		DE=ADDRESS TIME		A=00H
;
; DIRECTORY CODE : A=00H,01H,02H,03H IF NO ERROR
;                  A=0FFH IF ERROR
; ERROR CODE     : A=00H IF NO ERROR
;                  A=0FFH IF ERROR
; READ/WRITE CODE: A=00H IF NO ERROR
;		   A=01H READ  => END OF FILE
;			 WRITE => DIRECTORY FULL
;		   A=02H DISK FULL
;		   A=03H CLOSE ERROR DURING RANDOM RECORD READ/WRITE
;		   A=04H READ EMPTY RECORD DURING RANDOM RECORD READ
;		   A=05H DIRECTORY FULL DURING RANDOM RECORD WRITE
;		   A=06H RANDOM RECORD TOO LARGE DURING RANDOM RECORD READ/WRITE
;
;
CTABLE:	.DW	WBOOT			; WARM BOOT 
	.DW	RDCON			; CONSOLE INPUT
	.DW	BWRCON			; CONSOLE OUTPUT
	.DW	RDRDR			; READER INPUT
	.DW	WPUNCH			; PUNCH OUTPUT
	.DW	WLIST			; LIST OUTPUT
	.DW	DCIO			; DIRECT CONSOLE I/O
	.DW	GIOST			; GET I/O BYTE
	.DW	SIOST			; SET I/O BYTE
	.DW	MESS			; PRINT STRING
	.DW	RDBUF			; READ CONSOLE BUFFER
	.DW	TSTCS			; GET CONSOLE STATUS
	.DW	CMND12			; RETURN VERSION NUMBER
	.DW	CMND13			; RESET DISK SYSTEM
	.DW	CMND14			; SELECT DISK
	.DW	CMND15			; OPEN FILE
	.DW	CMND16			; CLOSE FILE
	.DW	F_SFIRST		; SEARCH FOR FIRST
	.DW	CMND18			; SEARCH FOR NEXT
	.DW	CMND19			; DELETE FILE
	.DW	CMND20			; READ SEQUENTIAL
	.DW	CMND21			; WRITE SEQUENTIAL
	.DW	CMND22			; MAKE FILE
	.DW	CMND23			; RENAME FILE
	.DW	CMND24			; RETURN LOGIN VECTOR
	.DW	CMND25			; RETURN CURRENT DISK
	.DW	CMND26			; SET DMA ADDRESS
	.DW	CMND27			; GET ADDRESS ALLOCATION VECTOR
	.DW	CMND28			; WRITE PROTECT DISK
	.DW	CMND29			; GET R/O VECTOR
	.DW	CMND30			; SET FILE ATTRIBUTES
	.DW	CMND31			; GET ADDRESS DISK PARAMETER HEADER(DPH) 
	.DW	CMND32			; GET/SET USER CODE
	.DW	CMND33			; READ RANDOM
	.DW	CMND34			; WRITE RANDOM
	.DW	CMND35			; COMPUTE FILE SIZE
	.DW	CMND36			; SET RANDOM RECORD
	.DW	CMND37			; RESET MULTIPLE DRIVE
	.DW	DUMMY			; NOT IMPLEMENTED 
	.DW	DUMMY			; NOT IMPLEMENTED 
	.DW	CMND40			; WRITE RANDOM WITH ZERO FILL
;
; I/O ROUTINES
;
; P2DOS CONSOLE INPUT
;
; READ CHARACTER FROM CONSOLE AND ECHO
;  IF CHAR=CR,LF,TAB,CONTH OR >=SPACE
;
RDCON:	CALL	GETCH			; GET CHARACTER
	CALL	TSTCH			; TEST IF CR,LF,TAB,CONTH OR >=SPACE
	CALL	NC,WRCON		; ECHO CHARACTER
EXIT:	LD	(PEXIT),A		; RETURN CHARACTER 
DUMMY:	RET				; AND EXIT P2DOS
;
; P2DOS WRITE CONSOLE
;
BWRCON:	LD	A,E			; COPY CHARACTER
	JR	WRCON			; AND OUTPUT IT
;
; READ READER
;
RDRDR:	CALL	READER			; GET CHARACTER FROM READER
	JR	EXIT			; AND RETURN IT TO CALLER 
;
; WRITE PUNCH
;
WPUNCH:	LD	C,E			; COPY CHARACTER
	JP	PUNCH			; AND OUTPUT IT TO PUNCH DEVICE
;
; WRITE LIST
;
WLIST:	LD	C,E			; COPY CHARACTER
	JP	LIST			; AND OUTPUT IT TO LIST DEVICE
;
; DIRECT CONSOLE INPUT/OUTPUT
;
DCIO:	LD	C,E			; COPY CHARACTER
	INC	E			; TEST IF 0FFH
	JR	Z,DCIO0			; YES DO INPUT
	INC	E			; TEST IF 0FEH
	JP	NZ,CONOUT		; NO THEN OUTPUT CHARACTER
	CALL	CONST			; GET CONSOLE STATUS
	JR	EXIT			; AND RETURN IT TO CALLER
DCIO0:	CALL	CONST			; GET CONSOLE STATUS
	OR	A			; TEST IT
	RET	Z			; EXIT IF NO CHARACTER PRESENT
	CALL	CONIN			; GET CHARACTER
	JR	EXIT			; AND RETURN IT TO CALLER
;
; GET I/O STATUS BYTE
;
GIOST:	LD	A,(RAMLOW+0x0003)	; GET I/O BYTE FROM RAM
	JR	EXIT			; AND RETURN IT TO CALLER
;
; SET I/O STATUS BYTE
;
SIOST:	LD	A,E			; COPY I/O BYTE
	LD	(RAMLOW+0x0003),A	; AND SAVE IT IN RAM
	RET				; EXIT TO CALLER
;
; TEST CONSOLE STATUS
;
TSTCS:	CALL	GCONST			; GET CONSOLE STATUS
	JR	EXIT			; AND RETURN IT TO CALLER
;
; OUTPUT CHAR (CONTROL CHAR = ^CHAR)
;
OUTCH:	CALL	TSTCH			; TEST IT CR,LF,TAB,CONTH OR >=SPACE
	JR	NC,WRCON		; YES THEN JUMP
	PUSH	AF			; SAVE CHARACTER
	LD	A,#"^"			; LOAD A WITH "^" 
	CALL	WRCON			; OUTPUT IT
	POP	AF			; GET CHARACTER BACK
	PUSH	AF			; SAVE IT AGAIN
	ADD	A,#"A"-1		; ADD OFFSET
	AND	#0x7F
	CALL	WRCON			; OUTPUT IT
	POP	AF			; GET CHARACTER
	RET				; RETURN TO CALLER
;
; ECHO CR,LF
;
CROUT:	LD	A,#CR			; A=CARRIAGE RETURN
	CALL	WRCON			; OUTPUT IT
	LD	A,#LF			; A=LINE FEED
					; FALL THROUGH TO OUTPUT ROUTINE
;
; WRITE CHARACTER ON CONSOLE
;
WRCON:	CP	#TAB			; TEST IF TAB
	JR	NZ,WRCON1		; NO THEN JUMP
WRCON0:	LD	A,#SPC			; EXPAND TAB WITH SPACES
	CALL	WRCON			; WRITE SPACE
	LD	A,(TABCNT)		; GET TAB COUNT
	AND	#7			; TEST IF DONE
	JR	NZ,WRCON0		; NO THEN REPEAT
	LD	A,#TAB			; RETURN TAB
	RET				; RETURN TO CALLER

WRCON1:	PUSH	AF			; SAVE CHARACTER
	CALL	GCONST			; TEST STATUS AND CONTS/CONTC
	POP	AF			; GET CHARACTER BACK
	PUSH	AF			; SAVE IT AGAIN
	LD	C,A			; COPY IT
	CALL	CONOUT			; OUTPUT IT
	POP	AF			; GET CHARACTER BACK
	PUSH	AF			; SAVE IT AGAIN
	LD	C,A			; COPY IT
	LD	A,(FCONTP)		; GET PRINTER ECHO FLAG 
	OR	A			; TEST IT
	CALL	NZ,LIST			; NON ZERO => OUTPUT CHAR TO PRINTER
	LD	A,(FLAGS)		; GET FLAG BYTE
	BIT	1,A			; TEST DELAY 256 BYTES ACTIVE
	JR	Z,WRCON2		; NO THEN EXIT
	LD	HL,#DELAY		; GET DELAY COUNTER
	XOR	A			; A=0 
	OR	(HL)			; TEST COUNTER=0
	JR	Z,WRCON2		; YES THEN EXIT
	DEC	(HL)			; ELSE DECREMENT COUNTER
WRCON2:	POP	AF			; RESTORE CHARACTER
					; FALL THROUGH TO COUNT ROUTINE
;
; COUNT CHARACTERS IN LINE    
;
COUNTC:	LD	HL,#TABCNT		; GET POINTER TO TAB COUNTER
	CP	#RUBOUT			; TEST IF CHARACTER = RUBOUT (0x7F == '')
	RET	Z			; YES NO UPDATE TAB COUNTER

	INC	(HL)			; INCREMENT TAB COUNTER
	CP	#SPC			; TEST IF CHAR >= ' '
	RET	NC			; YES, NORMAL CHARACTER THEN EXIT

	DEC	(HL)			; CONTROL CHARACTER, DECREMENT TAB COUNT
	CP	#CONTH			; TEST BACKSPACE
	JR	NZ,COUNT0		; NO BACKSPACE THEN JUMP

	DEC	(HL)			; DECREMENT TAB COUNTER
	RET				; AND EXIT

COUNT0:	CP	#CR			; TEST CARRIAGE RETURN
	JR	NZ,COUNT1		; NO THEN JUMP
	LD	(HL),#0			; RESET TAB COUNT
	RET				; AND EXIT

COUNT1:	CP	#TAB			; TEST TAB CHARACTER
	RET	NZ			; NO THEN EXIT
	PUSH	AF			; SAVE CHARACTER
	LD	A,(HL)			; GET TAB COUNT
	ADD	A,#8			; ADVANCE IT 8 POSITION
	AND	#0xF8			; SET IT TO NEXT TAB POSITION
	LD	(HL),A			; SAVE IT
	POP	AF			; RESTORE CHARACTER 
	RET				; AND EXIT
;
; GET CHARACTER FROM CONSOLE
;
GETCH:	LD	HL,#LASTCH		; GET POINTER TO LAST INPUT CHARACTER
	LD	A,(HL)			; GET CHARACTER
	LD	(HL),#0			; RESET LAST CHARACTER
	OR	A			; TEST IF CHARACTER PRESENT
	RET	NZ			; RETURN IF SO
	JP	CONIN			; ELSE GET CHARACTER
;
; GET CONSOLE STATUS
;
GCONST:	LD	A,(DELAY)		; GET 256 BYTES DELAY
	OR	A			; TEST IT
	JR	NZ,GCONS0		; NON ZERO, DELAY STILL ACTIVE OR DISABLED
	CALL	CONST			; GET CONSOLE STATUS
	OR	A			; TEST IT
	JR	NZ,GCONS1		; NON ZERO THEN GET CHARACTER
GCONS0:	LD	A,(LASTCH)		; GET LAST CHARACTER
	OR	A			; TEST IT
	JR	NZ,GCONS3		; NON ZERO THEN CHARACTER PRESENT
	CALL	CONST			; GET CONSOLE STATUS
	OR	A			; TEST IT
	RET	Z			; RETURN IF NO CHARACTER PRESENT
GCONS1:	CALL	CONIN			; GET CHARACTER
	CP	#CONTS			; TEST STOP CHARACTER
	JR	NZ,GCONS2		; NOT THEN EXIT CHARACTER
GCONS4:	CALL	CONIN			; GET NEXT CHARACTER
	CP	#CONTC			; TEST IF USER WANTS TO EXIT
	JP	Z,RAMLOW+0x0000		; YES THEN WARM BOOT
;
	.IF	XONOFF==TRUE
	CP	#CONTQ			; ^Q to turn on console output?
	JR	NZ,GCONS4		; no, igore character
	.ELSE
	.IF	NOXOFF==TRUE
	CP	#CONTS			; another ^S?
	JR	Z,GCONS4		; yes, don't restart console output
	.ENDIF
	.ENDIF
;
	JR	GCONST			; TEST AGAIN
GCONS2:	LD	(LASTCH),A		; SAVE CHARACTER
	LD	A,#0xFF			; SET DELAY COUNTER
	LD	(DELAY),A		; AND SAVE IT
GCONS3:	LD	A,#1			; CHARACTER PRESENT CODE
	RET				; RETURN TO CALLER
;
; TEST CHARACTER
;  EXIT CARRY=0: CR,LF,TAB,CONTH OR >=SPACE
;       CARRY=1: ALL OTHER CHARACTERS
;
TSTCH:	CP	#CR			; TEST CARRIAGE RETURN
	RET	Z			; RETURN IF SO
	CP	#LF			; TEST LINE FEED
	RET	Z			; RETURN IF SO
	CP	#TAB			; TEST TAB
	RET	Z			; RETURN IF SO
	CP	#CONTH			; TEST BACKSPACE
	RET	Z			; RETURN IF SO
	CP	#SPC			; TEST >=SPACE
	RET				; RETURN TO CALLER
;
; WRITE BACKSPACE,SPACE,BACKCPACE
;
WCONTH:
	CALL	WCONT0			; WRITE BACKSPACE
	LD	A,#SPC			; LOAD SPACE
	CALL	CONOUT			; AND OUTPUT IT
WCONT0:	LD	A,#CONTH		; LOAD BACKSPACE
	JP	CONOUT			; AND OUTPUT IT
;
; OUTPUT MESSAGE
;
MESS:	LD	A,(DE)			; GET BYTE FROM BUFFER
	CP	#DOLLAR			; TEST LAST BYTE
	RET	Z			; YES, THEN RETURN TO CALLER
	INC	DE			; POINT TO NEXT BYTE
	PUSH	DE			; SAVE POINTER
	CALL	WRCON			; OUTPUT CHARACTER
	POP	DE			; RESTORE POINTER
	JR	MESS			; AND TEST AGAIN
;
; AGAIN PRINTS #,CR,LF AND ADVANCES TO TABCX1
;
AGAIN:	LD	A,#SHARP		; LOAD '#'
	CALL	WRCON			; OUTPUT IT
AGAIN0:	CALL	CROUT			; OUTPUT CARRIAGE RETURN/LINE FEED
AGAIN1:	LD	HL,#TABCNT		; GET TAB COUNT POINTER
	LD	A,(TABCX1)		; GET POSITION FIRST CHARACTER LINE
	CP	(HL)			; CHECK IT
	RET	Z			; RETURN IF ON SAME POSITION
	LD	A,#SPC			; LOAD SPACE
	CALL	WRCON			; OUTPUT IT
	JR	AGAIN1			; AND TEST AGAIN


;
; DELETE CHAR
;  ENTRY : HL=START BUFFER-1
;          B =CHARACTER COUNTER (ALWAYS>0)
;===========================================================================
DELCH:	
;===========================================================================
;	out	(0xD2),a		; +++ GET NEW CHAR

	DEC	B			; DECREMENT CHARACTER COUNTER
	LD	A,(TABCNT)		; GET TAB COUNTER
	PUSH	AF			; SAVE IT
	PUSH	BC			; SAVE CHARACTER COUNTER
	LD	A,(TABCX1)		; GET POSITION FIRST CHARACTER LINE
	LD	(TABCNT),A		; SAVE IT IN TAB COUNTER

DELCH0:	LD	A,B			; COPY CHARACTER COUNTER
	OR	A			; TEST IF 0
	JR	Z,DELCH2		; YES THEN JUMP

	DEC	B			; DECREMENT IT
	INC	HL			; INCREMENT BUFFER POINTER
	LD	A,(HL)			; GET CHARACTER FROM BUFFER
	PUSH	HL			; SAVE BUFFER POINTER
	CALL	TSTCH			; TEST IF CR,LF,TAB,CONTH OR >=SP
	JR	NC,DELCH1		; YES THEN JUMP
	RRA				; ELSE MUST BE CONTROL CHARACTER
	CALL	COUNTC			; COUNT CONTROL CHARACTER TWICE
DELCH1:	CALL	COUNTC			; COUNT CHARACTER
	POP	HL			; GET BUFFER POINTER
	JR	DELCH0			; AND TEST AGAIN

DELCH2:	POP	BC			; RESTORE CHARACTER COUNTER
	POP	AF			; AND TAB COUNTER
	PUSH	HL			; SAVE BUFFER POINTER
	PUSH	BC			; AND CHARACTER COUNTER
	LD	HL,#TABCNT		; GET TAB COUNTER POINTER
	SUB	(HL)			; CALCULATE DIFFERENCE
DELCH3:	DEC	A			; DECREMENT IT
	CP	#8			; COMPARE WITH 8
	JR	NC,DELCH4		; JUMP IF >=8
	PUSH	AF			; SAVE DIFFERENCE
	CALL	WCONTH			; REMOVE CHARACTER END LINE
	POP	AF			; RESTORE COUNTER
	JR	DELCH3			; REMOVE MORE CHARACTERS
DELCH4:	POP	BC			; RESTORE CHARACTER COUNTER
	POP	HL			; RESTORE BUFFER POINTER
	RET				; AND RETURN TO CALLER 


;-------------------------------------------------------------------
;BDOS function 10 - Buffered console input
;-------------------------------------------------------------------

;Supported by: All versions, with variations

;Entered with C=0Ah, DE=address or zero.

;This function reads characters from the keyboard into a memory buffer until RETURN is pressed. 
;The Delete key is handled correctly. In later versions, more features can be used at this point; 
;ZPM3 includes a full line editor with recall of previous lines typed.

;On entry, DE is the address of a buffer. If DE=0 (in CP/M-86, DOS Plus etc, DX=0FFFFh), 
;the DMA address is used (CP/M 3 and later) and the buffer already contains data:;

;DE=address:                     DE=0 / DX=0FFFFh:
;buffer: DEFB    size            buffer: DEFB    size
;        DEFB    ?                       DEFB    len
;        DEFB    bytes                   DEFB    bytes

;The value at buffer+0 is the amount of bytes available in the buffer. 
;Once the limit has been reached, no more can be added, although the line editor can still be used.
;If DE=0 (in CP/M-86, DOS Plus etc, DX=0FFFFh) the next byte contains the number of bytes already in the buffer 
;otherwise this is ignored. 
;On return from the function, it contains the number of bytes present in the buffer.
;The bytes typed then follow. There is no end marker.
;-------------------------------------------------------
; READ BUFFER
;===========================================================================
RDBUF:	
;===========================================================================
	LD	A,(TABCNT)		; GET CURRENT POSITION CURSOR
	LD	(TABCX1),A		; SAVE IT
RDBUF0:	PUSH	IX			; SAVE START ADDRESS BUFFER
	POP	HL			; GET IT IN HL
	LD	C,(HL)			; GET MAXIMUM LINE LENGTH		; BUFFER[0] ==> MAX BUFFER LEN
	INC	HL			; INCREMENT TO LINE LENGTH POSITION	; BUFFER[1] ==> ACTUAL BUFFER LEN
	LD	B,#0			; CLEAR LINE LENGTH COUNTER
	PUSH	HL			; SAVE START LINE - 1			; BUFFER[2..N] == > LINE DATA

RDBUF1:	PUSH	HL			; SAVE REGISTERS
	PUSH	BC
RDBUF2:	CALL	GETCH			; GET CHARACTER (WAIT HERE)
	POP	BC			; RESTORE REGISTERS
	POP	HL

	AND	#0x7F			; MASK CHARACTER

;// CTRL-E ?
	CP	#CONTE			; TEST IF CONTE
	JR	NZ,RDBUF3		; NOT THEN JUMP 
	
	PUSH	HL			; SAVE REGISTERS
	PUSH	BC
	CALL	AGAIN0			; MOVE CURSOR TO NEXT LINE
	JR	RDBUF2			; AND GET NEXT CHAR


;// BACKSPACE ?
RDBUF3:	
;	out	(0xD2),a
	CP	#CONTH			; TEST BACKSPACE
	JR	NZ,RDBUF4		; NOT THEN JUMP
	
DOBACK:	
	LD	A,B			; TEST IF DELETING CHAR FROM EMPTY LINE, B == ACTUAL LINE LEN
	OR	A
	JR	Z,RDBUF1		; YES THEN GET NEXT CHAR

	POP	HL			; GET START LINE
	PUSH	HL			; AND SAVE IT AGAIN
	CALL	DELCH			; DELETE CHARACTER
	
	
	JR	RDBUF1			; GET NEXT CHARACTER

;// PRINT ?
RDBUF4:	CP	#CONTP			; TEST PRINT ENABLE/DISABLE
	JR	NZ,RDBUF6		; NOT THEN JUMP

	LD	A,(FCONTP)		; COMPLEMENT PRINT FLAG
	CPL
	LD	(FCONTP),A
RDBUF5:	JR	RDBUF1			; AND GET NEXT CHARACTER


;// CTRL-R ?
RDBUF6:	CP	#CONTR			; TEST REPEAT LINE
	JR	NZ,RDBUFA		; NOT THEN JUMP
	PUSH	BC			; SAVE REGISTERS
	CALL	AGAIN			; MOVE CURSOR TO NEXT LINE
	POP	BC			; RESTORE REGISTERS
	POP	HL			; GET START LINE
	PUSH	HL			; SAVE IT AGAIN
	PUSH	BC			; SAVE LINE COUNTER/MAXIMUM LINE LENGTH
RDBUF7:	LD	A,B			; TEST LAST CHARACTER ECHOED 
	OR	A
	JR	Z,RDBUF8		; YES THEN JUMP
	INC	HL			; INCREMENT POINTER
	LD	A,(HL)			; GET CHARACTER
	DEC	B			; DECREMENT LINE COUNTER
	PUSH	HL			; SAVE REGISTERS
	PUSH	BC
	CALL	OUTCH			; OUTPUT CHARACTER
	POP	BC			; RESTORE REGISTERS
	POP	HL
	JR	RDBUF7			; AND TEST END LINE
RDBUF8:	POP	BC			; RESTORE LINE COUNTER/MAX LINE LENGTH
RDBUF9:	JR	RDBUF5			; AND GET NEXT CHAR

;// CTRL-U ?
RDBUFA:	CP	#CONTU			; TEST DELETE LINE
	JR	NZ,RDBUFC		; NOT THEN JUMP
	POP	HL			; GET START LINE
	CALL	AGAIN			; MOVE CURSOR TO NEXT LINE
RDBUFB:	JR	RDBUF			; AND START ROUTINE AGAIN

;// CTRL-X ?
RDBUFC:	CP	#CONTX			; TEST DELETE LINE
	JR	NZ,RDBUFE		; NOT THEN JUMP
RDBUFD:	POP	HL			; GET START LINE
	LD	A,B			; TEST IF LAST CHARACTER DELETED
	OR	A
	JR	Z,RDBUFB		; YES START ROUTINE AGAIN
	PUSH	HL			; SAVE POINTER
	CALL	DELCH			; DELETE LAST CHARACTER LINE
	JR	RDBUFD			; TEST LAST CHARACTER DELETED

RDBUFE:	
	CP	#RUBOUT			; TEST DELETE LAST CHARACTER
	JR	Z,DOBACK		; Part of delete key fix

;Remove code for echoing deleted character--B.H.
;	LD	A,B			; TEST FIRST CHARACTER LINE
;	OR	A
;	JR	Z,RDBUF9		; YES, DO NOT DELETE
;	LD	A,(HL)			; GET LAST CHARACTER
;	DEC	HL			; DECREMENT POINTER LINE
;	DEC	B			; DECREMENT LINE COUNTER
;	JR	RDBUFG			; ECHO LAST CHARACTER
;---------------------------------------------------------------------

	CP	#CR			; TEST CARRIAGE RETURN
	JR	Z,RDBUFI		; YES, THEN EXIT
	CP	#LF			; TEST LINE FEED
	JR	Z,RDBUFI		; YES THEN EXIT
	INC	HL			; INCREMENT POINTER
	LD	(HL),A			; AND SAVE CHARACTER
	INC	B			; INCREMENT LINE COUNTER
RDBUFG:	PUSH	HL			; SAVE REGISTERS
	PUSH	BC
	CALL	OUTCH			; ECHO CHARACTER
	POP	BC			; RESTORE REGISTERS
	POP	HL
	CP	#CONTC			; TEST WARM BOOT
	LD	A,B			; GET LINE COUNT
	JR	NZ,RDBUFH		; NO WARM BOOT THEN JUMP
	CP	#1			; TEST CONTC IS FIRST CHARACTER LINE 
	JP	Z,RAMLOW+0x0000		; YES THEN EXECUTE WARM BOOT
RDBUFH:	CP	C			; TEST LINE LENGTH=MAXIMUM LINE LENGTH
	JR	NZ,RDBUF9		; NOT THEN GET NEXT CHARACTER
RDBUFI:	POP	HL			; GET START LINE - 1
	LD	(HL),B			; SAVE LINE COUNTER
	LD	A,#CR			; LOAD CARRIAGE RETURN
	JP	WRCON			; AND ECHO IT
;
;******************************************************************************
;*									      *
;*	 DISK FUNCTIONS							      *
;*									      *
;******************************************************************************
;
; RETURN VERSION NUMBER
;
CMND12:	LD	A,#0x22			; SET VERSION NUMBER
	JR	CMD25A			; AND EXIT
;
; RESET DISK SYSTEM
;
CMND13:	
	.IF	RESDSK==TRUE
;detect change between single and double sided disks if this function is
;supported.--B.H.
	CALL	SETDSK		
	.ENDIF	
	LD	HL,#0			; LOAD ZERO
	LD	(LOGIN),HL		; ALL DRIVES LOGED OUT
	LD	(DSKRO),HL		; ALL DRIVES READ/WRITE
	LD	HL,#RAMLOW+0x0080	; SET UP DMA ADDRESS
	LD	(DMA),HL		; AND SAVE IT
	CALL	STDMA			; DO P2BIOS CALL
	XOR	A			; SET DEFAULT DRIVE = 'A'
	LD	(DEFDRV),A		; SAVE IT
	CALL	SELDK			; SELECT DRIVE
	LD	A,(SUBFLG)		; GET SUBMIT FLAG
	JR	CMD25A			; EXIT
;
; SEARCH FOR FILE
;
F_SFIRST:	
	CALL	SELDRV			; SELECT DRIVE FROM FCB
	LD	A,(IX)			; GET DRIVE NUMBER FROM FCB
	SUB	#"?"			; TEST IF "?"
	JR	Z,CMD17B		; IF SO ALL ENTRIES MATCH
	LD	A,14(IX)		; GET SYSTEM BYTE
	CP	#"?"			; TEST IF "?" 
	JR	Z,CMD17A		; YES, JUMP
	LD	14(IX),#0		; LOAD SYSTEM BYTE WITH ZERO
CMD17A:	LD	A,#15			; TEST FIRST 15 ITEMS IN FCB
CMD17B:	CALL	SEARCH			; DO SEARCH
CMD17C:	LD	HL,(DIRBUF)		; COPY DIRECTORY BUFFER 
	LD	DE,(DMA)		; TO DMA ADDRESS
	LD	BC,#128			; DIRECTORY=128 BYTES 
	LDIR
	RET				; EXIT
;
; SEARCH FOR NEXT OCCURENCE FILE
;
CMND18:	LD	IX,(DCOPY)		; GET LAST FCB USED BY SEARCH
	CALL	SELDRV			; SELEXT DRIVE FROM FCB
	CALL	SEARCN			; SEARCH NEXT FILE MATCH
	JR	CMD17C			; AND COPY DIRECTORY TO DMA ADDRESS
;
; DELETE FILE
;
CMND19:	
	CALL	SELDRV			; SELECT DRIVE FROM FCB
	CALL	DELETE			; DELETE FILE
CMD19A:	LD	A,(SEAREX)		; GET EXIT BYTE 00=FILE FOUND,0FFH NOT
	JR	CMD25A			; AND EXIT
;
; RENAME FILE
;
CMND23:	
	CALL	SELDRV			; SELECT DRIVE FROM FCB
	CALL	RENAM			; RENAME FILE
	JR	CMD19A			; AND EXIT
;
; RETURN LOGIN VECTOR
;
CMND24:	LD	HL,(LOGIN)		; GET LOGIN VECTOR
CMD24A:	LD	(PEXIT),HL		; SAVE IT
	RET				; AND EXIT
;
; RETURN CURRENT DRIVE
;
CMND25:	LD	A,(DEFDRV)		; GET CURRENT DRIVE
CMD25A:	JP	EXIT			; AND EXIT
;
; RETURN ALV VECTOR
;
CMND27:	LD	HL,(ALV)		; GET ALLOCATION VECTOR
	JR	CMD24A			; AND EXIT
;
; RETURN DISK R/O VECTOR
;
CMND29:	LD	HL,(DSKRO)		; GET DISK R/O VECTOR
	JR	CMD24A			; AND EXIT
;
; CHANGE STATUS
;
CMND30:	CALL	SELDRV			; SELECT DRIVE FROM FCB
	CALL	CSTAT			; CHANGE STATUS
	JR	CMD19A			; AND EXIT
;
; RETURN DRIVE TABLE
;
CMND31:	LD	HL,(IXP)		; GET DRIVE TABLE
	JR	CMD24A			; AND EXIT
;
; SET/GET USER CODE
;
CMND32:	LD	A,E			; GET USER CODE
	INC	A			; TEST IF 0FFH
	LD	A,(USER)		; GET OLD USER CODE
	JR	Z,CMD25A		; IF 0FFH THEN EXIT
	LD	A,E			; GET NEW USER CODE
	AND	#0x1F			; MASK IT
	LD	(USER),A		; SAVE IT
	RET				; AND EXIT
;
; COMPUTE FILE SIZE COMMAND
;
CMND35:	CALL	SELDRV			; SELECT DRIVE FROM FCB
	CALL	FILSZ			; COMPUTE FILE SIZE
	JR	CMD19A			; AND EXIT
;
; SET RANDOM RECORD COUNT
;
CMND36:	LD	HL,#32			; SET POINTER TO NEXT RECORD
	CALL	CALRRC			; CALCULATE RANDOM RECORD COUNT
LDRRC:	LD	33(IX),D		; AND SAVE RANDOM RECORD COUNT
	LD	34(IX),C
	LD	35(IX),B
	RET				; AND EXIT
;
; RESET MULTIPLE LOGIN DRIVE
;
CMND37:	
	LD	A,E			; GET MASK LSB
	CPL				; COMPLEMENT IT
	LD	E,A 
	LD	A,D			; GET MASK MSB
	CPL				; COMPLEMENT IT
	LD	D,A
	LD	HL,(LOGIN)		; GET LOGIN VECTOR
	LD	A,E			; MASK LOGIN VECTOR
	AND	L			; LSB
	LD	L,A
	LD	A,D			; MASK LOGIN VECTOR
	AND	H			; MSB
	LD	H,A
	LD	(LOGIN),HL		; SAVE LOGIN VECTOR
	EX	DE,HL			; USE LOGIN VECTOR AS MASK
	LD	HL,(DSKRO)		; GET DRIVE R/O VECTOR
	LD	A,E			; MASK DRIVE R/O VECTOR
	AND	L			; LSB
	LD	L,A
	LD	A,D			; MASK DRIVE R/O VECTOR
	AND	H			; LSB
	LD	H,A
	LD	(DSKRO),HL		; SAVE DRIVE R/O VECTOR
	LD	A,(DEFDRV)		; log in default drive if needed
	CALL	SELDK
	XOR	A			; flag success
	JP	EXIT			; and return
;
;******************************************************************************
;*									      *
;*	 ERROR ROUTINES							      *
;*									      *
;******************************************************************************
;
; Bad sector error message separated into read/write error messages--B.H.
; BAD SECTOR ERROR
;
BADSEC:	JP	(HL)			; go to RDERR or WRTERR routine
;
; SELECT ERROR
;
SELERR:	LD	DE,#MSEL			; LOAD SELECT ERROR MESSAGE
	JR	WERROR			; AND DISPLAY ERROR
;
; FILE READ ONLY ERROR
;
FILRO:	LD	DE,#MFILRO		; LOAD FILE R/O MESSAGE
	LD	BC,#0xFFFF		; SET FILE R/O and ignore MESSAGE FLAG
	JR	ERROR			; AND DISPLAY ERROR
;
; Read Error Message--B.H.
;
RDERR:	LD	DE,#MRDERR
	JR	WERROR
;
; Write Error Message--B.H.
WRTERR:	LD	DE,#MWRTER
WERROR:	LD	B,#0			; set not ok to ignore
	JR	DERROR
;
; DRIVE READ ONLY ERROR
;
RDONLY:	LD	DE,#MRO			; LOAD DRIVE R/O MESSAGE
	LD	B,#0xFF			; set ok to ignore
DERROR:	LD	C,#0			; SET NO FILE R/O MESSAGE
;
;
; DISPLAY ERROR MESSAGE
;
; P2DOS ERROR ON D: ERROR MESSAGE
; FUNCTION = NN  [FILE = FILENAME.TYP]
;
ERROR:	PUSH	BC			; SAVE FILE R/O and IGNORE FLAG
	PUSH	DE			; SAVE ERROR MESSAGE POINTER
	CALL	CROUT			; DISPLAY CR/LF
	LD	A,(DEFDRV)		; GET CURRENT DRIVE
	ADD	A,#"A"			; MAKE ASCII
	LD	(MDRIVE),A		; SAVE IT
	LD	DE,#MBERR		; LOAD MESSAGE "Disk error on "
	CALL	MESS			; DISPLAY MESSAGE
	POP	DE			; GET ERROR MESSAGE POINTER
	CALL	MESS			; DISPLAY MESSAGE
	CALL	CROUT			; DISPLAY CR/LF
	LD	DE,#MBFUNC		; LOAD MESSAGE "FUNCTION ="
	CALL	MESS			; DISPLAY MESSAGE
	LD	A,(FUNCT)		; GET FUNCTION NUMBER
	PUSH	AF			; SAVE IT
	LD	BC,#100			; DISPLAY NUMBER / 100
	CALL	NUM
	LD	C,#10			; DISPLAY NUMBER / 10
	CALL	NUM
	LD	BC,#0x101			; ALWAYS DISPLAY NUMBER / 1
	CALL	NUM
	POP	AF			; GET FUNCTION NUMBER
	POP	BC			; GET FILE R/O FLAG
	PUSH	BC
	CP	#15			; TEST IF FCB USED IN COMMAND
	JR	C,ERROR3
	CP	#24
	JR	C,ERROR1
	CP	#30
	JR	Z,ERROR1
	CP	#33
	JR	C,ERROR3
	CP	#37
	JR	C,ERROR1
	CP	#40
	JR	NZ,ERROR3
ERROR1:	PUSH	IX			; YES THEN DISPLAY "FILE ="
	SUB	#19			; TEST DELETE FILE FUNCTION
	JR	NZ,ERROR2		; NOT THEN JUMP
	OR	C			; TEST FILE R/O FLAG
	JR	Z,ERROR2		; NO FILE R/O THEN JUMP
	CALL	CALDIR			; GET FCB FROM DIRECTORY BUFFER
	EX	(SP),HL			; SAVE IT
ERROR2:	LD	DE,#MFILE		; GET MESSAGE " FILE ="
	CALL	MESS			; DISPLAY MESSAGE
	POP	HL			; GET POINTER FCB
	LD	B,#8			; DISPLAY FISRT 8 CHARACTERS
	CALL	FILENM
	LD	A,#"."			; LOAD '.'
	PUSH	HL			; SAVE FCB POINTER
	CALL	WRCON			; ECHO IT
	POP	HL			; RESTORE FCB POINTER
	LD	B,#3			; DISPLAY LAST 3 CHARACTERS 
	CALL	FILENM
ERROR3:	CALL	GCONST			; TEST IF CHARACTER PRESENT
	OR	A
	JR	Z,ERROR4		; NO THEN JUMP
	CALL	GETCH			; GET CHARACTER
	JR	ERROR3			; AND TEST AGAIN
ERROR4:	CALL	GETCH			; GET CHARACTER
;P2DOS had a bug which did not allow the user to ignore a read/write error
;by hitting a key other than Control-C. This is the fix.--B.H.
;
;further modified to accept only a single ignore character
;
	POP	BC			; get back ignore flag
	CP	#CONTC			; warm boot?
	JR	Z,ERROR5		; yes
	AND	B			; possible to ignore (r/o error?)
	JR	Z,ERROR5		; no
	LD	HL,#FLAGS		; ignore enabled?
	BIT	2,(HL)
ERROR5:	JP	Z,RAMLOW+0x0000		; no
	CP	#IGNORE			; ignore?
	RET	Z			; yes
	PUSH	BC			; save ignore flag
	JR	ERROR4
;
; DISPLAY NUMBER
;
NUM:	LD	D,#0xFF			; LOAD NUMBER -1
NUM1:	INC	D			; INCREMENT NUMBER
	SUB	C			; DIVIDE BY C
	JR	NC,NUM1			; NOT FINISHED THEN LOOP
	ADD	A,C			; RESTORE LAST VALUE
	PUSH	AF			; SAVE IT
	LD	A,D			; TEST IF "0"
	OR	B			; AND IF LEADING ZERO
	JR	Z,NUM2			; YES, THEN EXIT 
	LD	B,D			; SET NO LEADING ZERO 
	LD	A,D			; GET NUMBER
	ADD	A,#"0"			; MAKE ASCII
	PUSH	BC			; SAVE REGISTERS
	CALL	WRCON			; ECHO NUMBER
	POP	BC			; RESTORE REGISTERS
NUM2:	POP	AF			; RESTORE NUMBER
	RET				; AND EXIT
;
; DISPLAY FILNAME.TYP
;
FILENM:	INC	HL			; INCREMENT POINTER FCB
	LD	A,(HL)			; GET CHARACTER FROM FCB
	AND	#0x7F			; MASK IT
	PUSH	HL			; SAVE REGISTERS
	PUSH	BC
	CALL	WRCON			; ECHO CHARACTER
	POP	BC			; RESTORE REGISTERS
	POP	HL
	DJNZ	FILENM			; REPEAT B TIMES
	RET				; AND EXIT
;
; ERROR MESSAGES
; Made more meaningful-B.H.
;
;Bad sector message replaced by read/write error messages
;MBADSC:	DEFM	'Bad sector$'
;
MSEL:	.ascii	'Non-existent drive$'
;
MFILRO:	.ascii	'File is '
;
MRO:	.ascii	'Read-Only$'
;
MBERR:	.ascii	'Disk error on '
MDRIVE:	.DB	0
	.DB	DRVSEP
	.ascii	' $'
;
MBFUNC:	.ascii	'Function = $'
;
MFILE:	.DB	59
	.ascii	' File = $'
;
MRDERR:	.ascii	'Read error$'
;
MWRTER:	.ascii	'Write error$'
;
; SELECT DISK FROM FCB
;
SELDRV:	LD	A,#0xFF			; SET DISK SELECT DONE FLAG
	LD	(FLDRV),A
	LD	A,(DEFDRV)		; GET CURRENT DRIVE
	LD	(DRIVE),A		; SAVE IT IN MEMORY
	LD	E,A			; SAVE IT IN REGISTER E
	LD	A,(IX)			; GET DRIVE FROM FCB
	LD	(FCB0),A		; SAVE IT
	CP	#"?"			; TEST IF "?"
	JR	Z,CMND14		; YES, THEN SELECT DRIVE FROM REGISTER E
	AND	#0x1F			; MASK DRIVE
	LD	A,E			; TEST IF ZERO
	JR	Z,SELDR0		; SELECT DRIVE FROM REGISTER E
	LD	A,(IX)			; GET DRIVE FROM FCB
	DEC	A			; DECREMENT DRIVE
SELDR0:	CALL	SELDK			; SELECT DRIVE
	LD	A,(IX)			; GET DRIVE FROM FCB
	AND	#0xE0			; REMOVE DRIVE BITS
	LD	B,A			; SAVE REGISTER
	LD	A,(USER)		; GET USER NUMBER
	OR	B			; INSERT USER NUMBER IN FCB
	LD	(IX),A
	RET				; AND EXIT
;       
; SELECT DISK
;
CMND14:	LD	A,E			; COPY DRIVE NUMBER
;
; SELECT DISK
;
SELDK:	AND	#0xF			; MASK DRIVE NUMBER
	LD	B,A			; SAVE COUNTER
	LD	DE,(LOGIN)		; GET LOGIN VECTOR
	OR	A			; TEST DRIVE 'A'
	JR	Z,SELDK1		; YES THEN JUMP
SELDK0:	RR	D			; SHIFT LOGIN VECTOR
	RR	E			; UNTIL BIT 0 REGISTER E
	DJNZ	SELDK0			; IS CURRENT DRIVE
SELDK1:	LD	HL,#DEFDRV		; GET POINTER LAST DRIVE
	BIT	0,E			; TEST IF DRIVE LOGGED IN
	JR	Z,SELDK2		; NO, LOGIN DRIVE
	CP	(HL)			; TEST SAME DRIVE
	RET	Z			; YES THEN EXIT
SELDK2:	LD	(HL),A			; SAVE NEW CURRENT DRIVE
	PUSH	DE			; SAVE DRIVE LOGGED IN FLAG
	LD	C,A			; COPY DRIVE NUMBER
	CALL	SELDSK			; DO P2BIOS SELECT 
	LD	A,H			; TEST IF ERROR 
	OR	L
	JR	NZ,SELDK3		; DRIVE NUMBER LEGAL
	LD	HL,(STSEL)		; load error message address
	JP	(HL)			; go to error routine
SELDK3:	LD	E,(HL)			; GET LSB TRANSLATION VECTOR
	INC	HL			; INCREMENT POINTER
	LD	D,(HL)			; GET MSB TRANSLATION VECTOR
	INC	HL			; INCREMENT POINTER
	LD	(TRANS),DE		; SAVE TRANSLATION VECTOR
	LD	(TEMP0),HL		; SAVE ADDRESS TEMP0
	INC	HL			; INCREMENT TO NEXT ADDRESS
	INC	HL
	LD	(TEMP1),HL		; SAVE ADDRESS TEMP1
	INC	HL			; INCREMENT TO NEXT ADDRESS
	INC	HL
	LD	(TEMP2),HL		; SAVE ADDRESS TEMP2
	INC	HL			; INCREMENT TO NEXT ADDRESS
	INC	HL

	LD	DE,#DIRBUF		; LOAD DIRBUF POINTER
	LD	BC,#8			; COPY DPH (DIRBF, DPB, CSV, ALV) last 4 pointers to LOCAL POINTERS
	LDIR

	LD	HL,(IXP)		; GET DRIVE PARAMETER ADDRESS
	LD	C,#15			; COPY 15 BYTES
	LDIR
	POP	DE			; GET DRIVE LOGGED IN FLAG
	BIT	0,E			; TEST IT
	RET	NZ			; DRIVE LOGGED IN SO RETURN
	LD	HL,(LOGIN)		; GET LOGIN VECTOR
	CALL	SDRVB			; SET DRIVE BIT IN LOGIN VECTOR
	LD	(LOGIN),HL		; SAVE LOGIN VECTOR
;
; INIT DRIVE
;  CLEAR ALV BIT BUFFER AFTER DRIVE RESET
;
INITDR:	LD	DE,(MAXLEN)		; GET LENGTH ALV BUFFER-1 (BITS)
	LD	A,#3			; DIVIDE BY 8
INITD0:	SRL	D			; TO GET BYTES
	RR	E
	DEC	A
	JR	NZ,INITD0
	LD	HL,(ALV)		; GET POINTER ALV BUFFER
	PUSH	HL
INITD1:	INC	HL			; zero n-1 bytes (skip first)
	LD	(HL),#0			; CLEAR 8 BITS
	DEC	DE			; DECREMENT COUNTER
	LD	A,D			; TEST IF COUNTER ZERO
	OR	E
	JR	NZ,INITD1		; NOT THEN JUMP
	POP	HL			; GET ALV POINTER
	LD	DE,(NDIR0)		; now, GET FIRST TWO BYTES ALV BUFFER 
	LD	(HL),E			; SAVE LSB
	INC	HL			; INCREMENT POINTER
	LD	(HL),D			; SAVE MSB
	LD	HL,(TEMP0)		; CLEAR NUMBER OF FILES
	LD	(HL),A			; CLEAR LSB
	INC	HL			; INCREMENT POINTER
	LD	(HL),A			; CLEAR MSB
	LD	(SUBFLG),A		; CLEAR SUBMIT FLAG (RESET DISK COMMAND)
	LD	(DIFF),A		; clear disk changed flag
	CALL	SETFCT			; SET FILE COUNT
INITD2:	LD	A,#0xFF			; UPDATE DIRECTORY CHECKSUM
	CALL	RDDIR			; READ FCB'S FROM DIRECTORY
	CALL	TSTFCT			; TEST LAST FCB
	RET	Z			; YES THEN EXIT
	CALL	CALDIR			; CALCULATE ENTRY POINT FCB
	LD	A,(HL)			; GET FIRST BYTE FCB
	CP	#0xE5			; TEST EMPTY DIRECTORY ENTRY
	JR	Z,INITD2		; YES THEN GET NEXT FCB
	CP	#0x21			; TEST TIME STAMP
	JR	Z,INITD2		; YES THEN GET NEXT FCB
	LD	A,(USER)		; GET USER NUMBER
	CP	(HL)			; TEST IF USER IS SAME
	JR	NZ,INITD3		; NO THEN JUMP
	INC	HL			; POINT TO FILE NAME
	LD	A,(HL)			; GET FIRST CHAR FILENAME
	SUB	#DOLLAR			; TEST IF '$'
	JR	NZ,INITD3		; NOT THEN JUMP
	DEC	A			; LOAD A WITH 0FFH
	LD	(SUBFLG),A		; SAVE IT IN SUBFLG 
INITD3:	LD	C,#1			; SET BIT IN ALV BUFFER
	CALL	FILLBB			; SET BITS FROM FCB IN ALV BUFFER
	CALL	SETLF			; UPDATE LAST FILE COUNT
	JR	INITD2			; AND GET NEXT FCB
;
; SET DRIVE BIT IN HL
;
SDRVB:	EX	DE,HL			; COPY HL=>DE 
	LD	HL,#1			; GET MASK DRIVE "A"
	LD	A,(DEFDRV)		; GET CURRENT DRIVE
	OR	A			; TEST IF DRIVE "A"
	JR	Z,SDRVB1		; YES THEN DONE
SDRVB0:	ADD	HL,HL			; GET NEXT MASK
	DEC	A			; DECREMENT DRIVE COUNTER
	JR	NZ,SDRVB0		; AND TEST IF DONE
SDRVB1:	LD	A,D			; HL=HL OR DE
	OR	H
	LD	H,A
	LD	A,E
	OR	L
	LD	L,A
	RET				; EXIT
;
; CALCULATE SECTOR/TRACK DIRECTORY
;
STDIR:	LD	HL,(FILCNT)		; GET FCB COUNTER DIRECTORY
	SRL	H			; DIVIDE BY 4
	RR	L			; (4 FCB'S / SECTOR)
	SRL	H
	RR	L
	LD	(RECDIR),HL		; SAVE VALUE (USED BY CHECKSUM)
	EX	DE,HL			; COPY IT TO DE
	LD	HL,#0			; CLEAR HL
;
; CALCULATE SECTOR/TRACK
;  ENTRY: HL,DE=SECTOR NUMBER (128 BYTE SECTOR)
;  RESULT SET TRACK  =HL,DE  /  MAXSEC
;         SET SECTOR =HL,DE MOD MAXSEC
;
CALST:	LD	BC,(MAXSEC)		; GET SECTORS/TRACK
	LD	A,#17			; SET UP LOOP COUNTER
CALST0:	OR	A			; TEST HL>=BC
	SBC	HL,BC
	CCF
	JR	C,CALST1		; YES THEN JUMP
	ADD	HL,BC			; NO THEN RETORE HL
	OR	A			; AND CLEAR CARRY
CALST1:	RL	E			; SHIFT RESULT IN DE
	RL	D
	DEC	A			; TEST LAST BIT DONE
	JR	Z,CALST2		; YES THEN EXIT
	RL	L			; SHIFT NEXT BIT IN HL
	RL	H
	JR	CALST0			; CONTINUE
CALST2:	PUSH	HL			; SAVE SECTOR NUMBER
	LD	HL,(NFTRK)		; GET FIRST TRACK
	ADD	HL,DE			; ADD TRACK NUMBER
	LD	B,H			; COPY IT TO BC
	LD	C,L
	CALL	SETTRK			; P2BIOS CALL SET TRACK
	POP	BC			; RESTORE SECTOR NUMBER
	LD	DE,(TRANS)		; GET TRANSLATION TABLE ADDRESS
	CALL	SECTRN			; P2BIOS CALL SECTOR TRANSLATION 
	LD	B,H			; COPY RESULT TO BC
	LD	C,L
	JP	SETSEC			; P2BIOS CALL SET SECTOR
;
; GET DISK MAP BLOCK NUMBER FROM FCB
;  EXIT HL=ADDRESS FCB
;       DE=DM
;       BC=OFFSET IN DM
;
GETDM:	LD	C,32(IX)		; GET NEXT RECORD
	LD	A,(NBLOCK)		; GET NUMBER OF BLOCKS
	LD	B,A			; SAVE IT 
GETDM0:	SRL	C			; SHIFT NEXT RECORD 
	DJNZ	GETDM0			; NUMBER OF BLOCKS TIMES
GETDM1:	CPL				; COMPLEMENT NUMBER OF BLOCKS
	ADD	A,#9			; ADD 9
	LD	B,A			; B=8-NUMBER OF BLOCKS
	LD	A,(NEXTND)		; GET EXTENT MASK
	AND	12(IX)			; MASK WITH EXTENT
	RRCA				; ROTATE ONE RIGHT
GETDM2:	RLCA				; ROTATE ONE LEFT
	DJNZ	GETDM2			; 8-NUMBER OF BLOCKS TIMES
GETDM3:	ADD	A,C			; ADD THE TWO VALUES TO GET ENTRY FCB
GETDM4:	PUSH	IX			; GET FCB ADDRESS
	POP	HL
	LD	C,#16			; ADD OFFSET 16 TO POINT TO DM
	ADD	HL,BC
	LD	C,A			; ADD ENTRY FCB
	ADD	HL,BC
	LD	A,(MAXLEN+1)		; TEST 8 BITS/16 BITS FCB ENTRY
	OR	A			; 16 bits => jump
	LD	E,(HL)			; GET 8 BIT VALUE
	LD	D,A			; MAKE MSB ZERO (if a=0)
	RET	Z			; AND EXIT
	ADD	HL,BC			; else,	ADD TWICE (16 BIT VALUES)
	LD	E,(HL)			; GET LSB
	INC	HL			; INCREMENT POINTER
	LD	D,(HL)			; GET MSB
	DEC	HL			; DECREMENT POINTER
	RET				; AND EXIT
;
; CALCULATE SECTOR NUMBER 
;  ENTRY: DE=BLOCK NUMBER FROM FCB
;
CALSEC:	LD	HL,#0			; CLEAR MSB SECTOR NUMBER
	LD	A,(NBLOCK)		; GET LOOP COUNTER
	LD	B,A			; SAVE IT IN B
CALSC0:	SLA	E			; SHIFT L,D,E 
	RL	D
	RL	L
	DJNZ	CALSC0			; B TIMES
CALSC1:	LD	A,(NMASK)		; GET SECTOR MASK
	AND	32(IX)			; AND WHIT NEXT RECORD
	OR	E			; SET UP LSB SECTOR NUMBER
	LD	E,A
	RET				; AND EXIT
;
; CALCULATE DIRBUF ENTRY POINT
;
CALDIR:	LD	HL,(DIRBUF)		; GET START ADDRESS DIRBUF
	LD	A,(SECPNT)		; GET SECTOR POINTER
	ADD	A,L			; ADD L=L+A
	LD	L,A
	RET	NC			; NO CARRY EXIT
	INC	H			; INCREMENT H
	RET				; AND EXIT
;
; INIT FILE COUNT
;
SETFCT:	LD	HL,#-1			; SET UP FILE COUNT
	LD	(FILCNT),HL		; SAVE IT
	RET				; AND EXIT
;
; TEST FILE COUNT
;
TSTFCT:	LD	HL,(FILCNT)		; TEST FILE COUNT=0FFFFH
	LD	A,H			; GET MSB 
	AND	L			; AND LSB
	INC	A			; TEST IF RESULT=0FFH
	RET				; AND EXIT
;
; SET LAST FILE
;
SETLF:	CALL	TSTLF			; TEST LAST FILE
	RET	C			; NO THEN EXIT
	INC	DE			; INCREMENT LAST FILE
	LD	(HL),D			; SAVE IT IN TEMP0
	DEC	HL
	LD	(HL),E
	RET				; AND EXIT
;
; TEST LAST FILE
;
TSTLF:	LD	HL,(TEMP0)		; GET POINTER TO LAST FILE 
	LD	DE,(FILCNT)		; GET FILE COUNTER
	LD	A,E			; SUBTRACT DE-(HL)
	SUB	(HL)
	INC	HL
	LD	A,D
	SBC	A,(HL)
	RET				; EXIT
;
; GET NEXT FCB FROM DRIVE
; ENTRY A=0 CHECK CHECKSUM, A=0FFH UPDATE CHECKSUM
;
RDDIR:	LD	C,A			; SAVE CHECKSUM FLAG
	LD	HL,(FILCNT)		; GET FILE COUNTER
	INC	HL			; INCREMENT IT
	LD	(FILCNT),HL		; AND SAVE IT
	LD	DE,(NFILES)		; GET MAXIMUM NUMBER OF FILES
	OR	A			; CLEAR CARRY
	SBC	HL,DE			; TEST IF LAST FILE
	ADD	HL,DE
	JR	Z,RDDIR0		; NO JUMP
	JR	NC,SETFCT		; YES SET FILE COUNT TO 0FFFFH
RDDIR0:	LD	A,L			; GET FILE COUNT LSB
	ADD	A,A			; *32 
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,A
	AND	#0x60			; MASK IT
	LD	(SECPNT),A		; SAVE IT FOR LATER USE
	RET	NZ			; RETURN IF NOT FISRT FCB SECTOR
	PUSH	BC			; SAVE CHECKSUM FLAG
	CALL	STDIR			; CALCULATE SECTOR/TRACK DIRECTORY
	CALL	READDR			; READ SECTOR DIRECTORY
	POP	BC			; RESTORE CHECKSUM FLAG
;
; UPDATE/CHECK CHECKSUM DIRECTORY
; ENTRY C=0 CHECK CHECKSUM, C=0FFH UPDATE CHECKSUM
;
CHKDIR:	LD	HL,(NCHECK)		; GET NUMBER OF CHECKED RECORDS
	LD	DE,(RECDIR)		; GET CURRENT RECORD
	OR	A			; CLEAR CARRY
	SBC	HL,DE			; TEST CURRENT RECORD 
	RET	Z			; EXIT IF ZERO
	RET	C			; EXIT IF GREATER THEN NCHECK
	LD	HL,(DIRBUF)		; GET DIRBUF
	LD	B,#128			; SET UP COUNTER
	XOR	A			; CLEAR CHECKSUM
CHKDR0:	ADD	A,(HL)			; ADD CHECKSUM
	INC	HL			; INCREMENT POINTER
	DJNZ	CHKDR0			; 128 TIMES
	LD	HL,(CSV)		; GET POINTER CHECKSUM DIRECTORY
	ADD	HL,DE			; ADD CURRENT RECORD
	INC	C			; TEST CHECKSUM FLAG
	JR	Z,CHKDR1		; 0FFH=> UPDATE CHECKSUM
	CP	(HL)			; TEST CHECKSUM
	RET	Z			; EXIT IF OK
;Automatic disk logging--instead of setting read/only flag when disk is
;changed, a disk changed flag is set.  The disk is reset when the SEARCH
;routine is called.
;	JP	SETWPD
	LD	A,#TRUE			; set disk changed flag
	LD	(DIFF),A
	JP	SETFN			; set number of files
CHKDR1:	LD	(HL),A			; UPDATE CHECKSUM
	RET				; AND EXIT
;
; READ SECTOR FROM DRIVE
;
;
;Readr and Writer modified to give separate error messages--B.H.
READR:	CALL	READ			; P2BIOS CALL READ SECTOR
	LD	HL,#RDERR
	JR	WRITE0
;
; WRITE SECTOR ON DRIVE
;
WRITER:	CALL	WRITE			; P2BIOS CALL WRITE SECTOR
	LD	HL,#WRTERR
WRITE0:	OR	A			; TEST EXIT CODE
	RET	Z			; EXIT IF OK
	PUSH	HL			; go to "bad sector" routine
	LD	HL,(STBDSC)
	EX	(SP),HL
	RET				; P2DOS ERROR ON D: BAD SECTOR
;
; READ DIRECTORY FROM DRIVE
;
READDR:	CALL	DMADIR			; SET UP DMA DIRECTORY
	CALL	READR			; READ RECORD
	JR	STDMA			; SET UP DMA USER
;
; WRITE DIRECTORY ON DRIVE
;
WRITDR:	LD	C,#0xFF			; UPDATE CHECKSUM DIRECTORY
	CALL	CHKDIR
	CALL	DMADIR			; SET UP DMA DIRECTORY 
	LD	C,#1			; WRITE DIRECTORY FLAG
	CALL	WRITER			; WRITE RECORD
	JR	STDMA			; SET UP DMA USER



;.INCL "P2DOS2"
;
; SET DMA ADDRESS COMMAND
;
CMND26:	LD	(DMA),DE		; SAVE DMA ADDRESS
;
; SET DMA ADDRESS
;
STDMA:	LD	BC,(DMA)		; GET DMA ADDRESS
	JR	DMADR0			; AND DO P2BIOS CALL
;
; SET DMA ADDRESS DIRECTORY
;
DMADIR:	LD	BC,(DIRBUF)		; GET DMA ADDRESS DIRECTORY
DMADR0:	JP	SETDMA			; P2BIOS CALL SET DMA
;
; GET BIT FROM ALV BUFFER
;  ENTRY DE=BLOCK NUMBER
;  EXIT  A =BIT IN LSB
;        B =BITNUMBER IN A
;        HL=POINTER IN ALV BUFFER
;
GETBIT:	LD	A,E			; GET BIT NUMBER
	AND	#7			; MASK IT
	INC	A			; ADD 1
	LD	B,A			; SAVE IT
	LD	C,A			; TWICE
	SRL	D			; GET BYTE NUMBER
	RR	E			; DE=DE/8
	SRL	D
	RR	E
	SRL	D
	RR	E
	LD	HL,(ALV)		; GET START ADDRESS ALV BUFFER
	ADD	HL,DE			; ADD BYTE NUMBER
	LD	A,(HL)			; GET 8 BITS
GETBT0:	RLCA				; GET CORRECT BIT
	DJNZ	GETBT0
	LD	B,C			; RESTORE BIT NUMBER
	RET				; AND RETURN TO CALLER
;
; SET/RESET BIT IN ALV BUFFER
;  ENTRY DE=BLOCK NUMBER
;        C =0 RESET BIT, C=1 SET BIT
;
SETBIT:	PUSH	BC			; SAVE SET/RESET BIT
	CALL	GETBIT			; GET BIT
	AND	#0xFE			; MASK IT
	POP	DE			; GET SET/RESET BIT
	OR	E			; SET/RESET BIT
SETBT0:	RRCA				; ROTATE BIT IN CORRECT POSITION
	DJNZ	SETBT0
	LD	(HL),A			; SAVE 8 BITS
	RET				; AND RETURN TO CALLER
;
; FILL BIT BUFFER FROM FCB IN DIRBUF
;  ENTRY C=0 RESET BIT, C=1 SET BIT
;
FILLBB:	CALL	CALDIR			; GET DIRECTORY ENTRY
	LD	DE,#16			; GET OFFSET DM BLOCK
	ADD	HL,DE			; ADD OFFSET
	LD	B,E			; GET BLOCK COUNTER
FILLB0:	LD	E,(HL)			; GET LSB BLOCK NUMBER
	INC	HL			; INCREMENT POINTER
	LD	D,#0			; RESET MSB BLOCK NUMBER
	LD	A,(MAXLEN+1)		; TEST >256 BLOCKS PRESENT
	OR	A
	JR	Z,FILLB1		; NO THEN JUMP
	DEC	B			; DECREMENT BLOCK COUNTER
	LD	D,(HL)			; GET CORRECT MSB
	INC	HL			; INCREMENT POINTER
FILLB1:	LD	A,D			; TEST BLOCK NUMBER
	OR	E			
	JR	Z,FILLB2		; ZERO THEN GET NEXT BLOCK
	PUSH	HL			; SAVE POINTER
	PUSH	BC			; SAVE COUNTER AND SET/RESET BIT
 	LD	HL,(MAXLEN)		; GET MAXIMUM LENGTH ALV BUFFER
	OR	A			; RESET CARRY
	SBC	HL,DE			; TEST DE<=MAXLEN ALV BUFFER 
	CALL	NC,SETBIT		; YES THEN INSERT BIT
	POP	BC			; GET COUNTER AND SET/RESET BIT
	POP	HL			; GET POINTER
FILLB2:	DJNZ	FILLB0			; REPEAT FOR ALL DM ENTRIES
	RET				; AND RETURN TO CALLER
;
; SET WRITE PROTECT DISK COMMAND
;
CMND28:
;
; SET WRITE PROTECT DISK
;
SETWPD:	LD	HL,(DSKRO)		; GET DISK R/O VECTOR
	CALL	SDRVB			; INCLUDE DRIVE BIT
	LD	(DSKRO),HL		; SAVE DISK R/O BIT
SETFN:	LD	DE,(NFILES)		; GET MAXIMUM NUMBER OF FILES-1 
	INC	DE			; INCREMENT IT 
	LD	HL,(TEMP0)		; GET POINTER TO DISK PARAMETER BLOCK 
	LD	(HL),E			; AND SAVE NUMBER OF FILES
	INC	HL
	LD	(HL),D
	RET				; AND RETURN TO CALLER
;
; CHECK FILE R/O BIT
;
CHKFRO:	CALL	CALDIR			; GET DIRECTORY ENTRY
CHKFR0:	LD	DE,#2			; OFFSET TO PUBLIC FILE BIT
	ADD	HL,DE			; ADD OFFSET
	BIT	7,(HL)			; TEST PUBLIC FILE
	JR	NZ,CHKFR1		; YES THEN ERROR
	LD	E,#7			; OFFSET TO FILE R/O BIT
	ADD	HL,DE			; ADD OFFSET
	BIT	7,(HL)			; TEST FILE R/O
;
	.IF	SYSRO==TRUE			; system files r/o option
	JR	NZ,CHKFR1		; YES THEN ERROR
	INC	HL			; INCREMENT TO SYSTEM FILE 
	BIT	7,(HL)			; TEST SYSTEM FILE
	.ENDIF
;
	RET	Z			; not read only
CHKFR1:	LD	HL,(SFILRO)		; GET POINTER TO FILE R/O MESSAGE
	JP	(HL)			; DISPLAY MESSAGE
;
; CHECK DRIVE READ ONLY
;
CHKRO:	LD	HL,(DSKRO)		; GET DRIVE R/O VECTOR
	CALL	SDRVB			; SET DRIVE BIT
	SBC	HL,DE			; TEST EXTRA BIT ADDED
	RET	NZ			; YES THEN DRIVE NOT R/O
	LD	HL,(STRO)		; GET POINTER TO DRIVE R/O MESSAGE
	JP	(HL)			; DISPLAY MESSAGE
;
; GET FREE BLOCK FROM ALV BUFFER
;  ENTRY DE=OLD BLOCK NUMBER
;  EXIT  DE=NEW BLOCK NUMBER (0 IF NO FREE BLOCK)
;   HL COUNTS UP,DE COUNTS DOWN
;
GETFRE:	LD	H,D			; COPY OLD BLOCK TO HL
	LD	L,E
GETFR0:	LD	A,D			; TEST DOWN COUNTER IS ZERO
	OR	E
	JR	Z,GETFR1		; YES THEN JUMP
	DEC	DE			; DECREMEMT DOWN COUNTER
	PUSH	HL			; SAVE UP/DOWN COUNTER
	PUSH	DE
	CALL	GETBIT			; GET BIT FROM ALV BUFFER
	RRA				; TEST IF ZERO
	JR	NC,GETFR3		; YES THEN FOUND EMPTY BLOCK
	POP	DE			; GET UP/DOWN COUNTER
	POP	HL
GETFR1:	LD	BC,(MAXLEN)		; GET MAXIMUM ALV LENGTH-1 IN BC
	OR	A			; CLEAR CARRY
	SBC	HL,BC			; TEST HL>=LENGTH ALV-1
	ADD	HL,BC			; RESTORE HL (FLAGS ARE NOT AFFECTED)
	JR	NC,GETFR2		; END BUFFER THEN JUMP
	INC	HL			; INCREMENT UP COUNTER
	PUSH	DE			; SAVE DOWN/UP COUNTER
	PUSH	HL
	EX	DE,HL			; SAVE UP COUNTER IN DE
	CALL	GETBIT			; GET BIT FROM ALV BUFFER
	RRA				; TEST IF ZERO
	JR	NC,GETFR3		; YES THEN FOUND EMPTY BLOCK
	POP	HL			; GET DOWN/UP COUNTER
	POP	DE
	JR	GETFR0			; AND TEST NEXT BLOCK 
GETFR2:	LD	A,D			; TEST IF LAST BLOCK TESTED
	OR	E
	JR	NZ,GETFR0		; NO THEN TEST NEXT BLOCK
	RET				; EXIT (DE=0)
GETFR3:	SCF				; SET BLOCK NUMBER USED
	RLA				; SAVE BIT
	CALL	SETBT0			; PUT BIT IN ALV BUFFER
	POP	DE			; GET CORRECT COUNTER
	POP	HL			; RESTORE STACK POINTER
	RET				; EXIT (DE=BLOCK NUMBER)
;
; SEARCH FOR FILE NAME
;  ENTRY: A : NUMBER OF BYTES TO SEARCH FOR
;
SEARCH:	LD	(SEARNB),A		; save number of bytes
	LD	A,(DIFF)		;log in disk if it has changed
	AND	A
	CALL	NZ,INITDR			
	LD	A,#0xFF			; SET EXIT CODE TO 0FFH (NOT FOUND)
	LD	(SEAREX),A
	LD	(DCOPY),IX		; COPY FCB POINTER TO RAM (SEARCH NEXT)
	CALL	SETFCT			; INITIATE FILE COUNTER
;
; The following note by Benjamin Ho describes a VERY NON-STANDARD SIDE
; EFFECT that is in no way guaranteed. Nowhere does any documment
; claim that a BIOS call to HOME force a directory read. Re-install
; if your system needs it.
;
;Mod 2.1 had a bug in which the directory of a changed disk would not be
;read.  Adding CALL HOME forces a directory read--B.H.
;
;	CALL HOME			; Commented out by D.C.K.
;
; SEARCH NEXT FILE NAME
;
SEARCN:	XOR	A			; CHECK CHECKSUM DIRECTORY
	CALL	RDDIR			; GET FCB FROM DIRECTORY
	CALL	TSTFCT			; TEST IF PAST LAST ENTRY
	JR	Z,SEARC8		; YES THEN JUMP
	LD	DE,(DCOPY)		; GET FCB POINTER
	LD	A,(DE)			; GET FIRST BYTE
	CP	#0xE5			; TEST IF SEARCHING EMPTY DIRECTORY
	JR	Z,SEARC1		; YES THEN JUMP
	PUSH	DE			; SAVE FCB POINTER
	CALL	TSTLF			; TEST LAST FILE ON THIS DRIVE
	POP	DE			; RESTORE FCB POINTER
	JR	NC,SEARC8		; YES THEN JUMP
SEARC1:	CALL	CALDIR			; GET ENTRY IN DIRECTORY
	LD	A,(HL)			; GET FIRST BYTE DIRECTORY ENTRY
	CP	#0x21			; TEST TIME STAMP
	JR	Z,SEARCN		; YES THEN GET NEXT DIRECTORY ENTRY
	LD	A,(SEARNB)		; GET NUMBER OF BYTES TO SEARCH FOR
	LD	B,A			; SAVE IT IN COUNTER
	XOR	A			; CLEAR ACCU
	LD	(SEARQU),A		; CLEAR QUESTION MARK DETECTED FLAG
	LD	(SEARPU),A		; CLEAR PUBLIC FILE FLAG
	LD	C,A			; CLEAR COUNTER
SEARC2:	LD	A,B			; TEST IF COUNTER IS ZERO
	OR	A
	JR	Z,SEARC9		; YES THEN JUMP
	LD	A,(DE)			; GET BYTE FROM FCB
	SUB	#"?"			; TEST IF QUESTION MARK
	JR	Z,SEARC6		; YES THEN JUMP
	LD	A,C			; GET FCB COUNTER
	OR	A			; TEST FIRST BYTE
	JR	NZ,SEARC3		; NO THEN JUMP
	LD	A,(FLAGS)		; GET FLAG BYTE
	BIT	0,A			; TEST PUBLIC FILE ENABLE
	JR	Z,SEARC3		; NO THEN JUMP
	INC	HL			; GET POINTER TO PUBLIC BIT
	INC	HL
	BIT	7,(HL)			; TEST PUBLIC BIT DIRECTORY
	DEC	HL			; RESTORE POINTER
	DEC	HL
	JR	Z,SEARC3		; NO PUBLIC FILE THEN JUMP
	LD	A,(DE)			; GET FIRST BYTE FCB
	CP	#0xE5			; TEST IF SEARCHING EMPTY DIRECTORY
	JR	Z,SEARC3		; YES THEN JUMP
	XOR	(HL)			; TEST FCB=DIRECTORY ENTRY
	AND	#0x7F			; MASK IT
	JR	Z,SEARC5		; YES THEN JUMP
	AND	#0xE0			; MASK USER NUMBER
	JR	NZ,SEARC3		; NOT THE SAME THEN JUMP
	DEC	A			; A=0FFH
	LD	(SEARPU),A		; SET PUBLIC FILE FOUND
	JR	SEARC5			; JUMP FOUND
SEARC3:	LD	A,C			; GET FCB COUNTER
	CP	#13			; TEST IF USER CODE
	JR	Z,SEARC5		; YES THEN NO TEST
	CP	#12			; TEST IF EXTENT NUMBER
	LD	A,(DE)			; GET BYTE FROM FCB
	JR	Z,SEARC7		; JUMP IF EXTENT NUMBER
	XOR	(HL)			; TEST BYTE FCB=BYTE DIRECTORY ENTRY
	AND	#0x7F			; MASK IT
SEARC4:	JR	NZ,SEARCN		; NOT THE SAME THEN GET NEXT ENTRY
SEARC5:	INC	DE			; INCREMENT POINTER FCB
	INC	HL			; INCREMENT POINTER DIRECTORY ENTRY
	INC	C			; INCREMENT COUNTER
	DEC	B			; DECREMENT COUNTER
	JR	SEARC2			; TEST NEXT BYTE
SEARC6:	DEC	A			; SET QUESTION MARK FOUND FLAG
	LD	(SEARQU),A		
	JR	SEARC5			; JUMP FOUND
SEARC7:	PUSH	BC			; SAVE COUNTERS
	XOR	(HL)			; TEST EXTENTS
	LD	B,A			; SAVE IT
	LD	A,(NEXTND)		; GET EXTENT MASK
	CPL				; COMPLEMENT IT
	AND	#0x1F			; MASK IT
	AND	B			; MASK EXTENTS
	POP	BC			; RETORE COUNTERS
	JR	SEARC4			; AND TEST RESULT
SEARC8:	CALL	SETFCT			; ERROR SET FILE COUNTER
	LD	A,#0xFF			; AND SET EXIT CODE
	LD	(PEXIT),A
	RET				; RETURN TO CALLER
SEARC9:	LD	A,(SEARQU)		; GET QUESTION MARK FOUND FLAG
	LD	B,A			; SAVE IT
	LD	A,(SEARPU)		; GET PUBLIC FILE FLAG
	AND	B			; TEST IF PUBLIC FILE AND QUESTION MARK
	JR	NZ,SEARC4		; YES THEN SEARCH FOR NEXT ENTRY
	CALL	SETLF			; UPDATE LAST FILE COUNT (EMPTY FCB)
	LD	A,(FILCNT)		; GET FILE COUNTER
	AND	#3			; MASK IT
	LD	(PEXIT),A		; AND SET EXIT CODE
	XOR	A			; CLEAR EXIT CODE SEARCH
	LD	(SEAREX),A
	RET				; AND RETURN TO CALLER
;
;DELETE FILE
;
DELETE:	CALL	CHKRO			; CHECK DISK R/O
	LD	A,#12			; NUMBER OF BYTES TO SEARCH FOR
	CALL	SEARCH			; SEARCH FILE
DEL0:	CALL	TSTFCT			; TEST IF FILE FOUND
	RET	Z			; NOT THEN EXIT
	CALL	CHKFRO			; CHECK FILE R/O
	CALL	CALDIR			; GET ENTRY POINT DIRECTORY
	LD	(HL),#0xE5		; REMOVE FILE
	LD	C,#0			; REMOVE BITS ALV BUFFER
	CALL	FILLBB 
	CALL	WRFCB1			; WRITE DIRECTORY BUFFER ON DISK
	CALL	SEARCN			; SEARCH NEXT ENTRY
	JR	DEL0			; AND TEST IT
;
; RENAME FILE
;
RENAM:	CALL	CHKRO			; CHECK DISK R/O
	LD	A,#12			; NUMBER OF BYTES TO SEARCH FOR
	CALL	SEARCH			; SEARCH FILE
RENAM0:	CALL	TSTFCT			; TEST IF FILE FOUND
	RET	Z			; NOT THEN EXIT
	CALL	CHKFRO			; CHECK FILE R/O
	LD	BC,#(12*256)+16		; COPY FCB+16 TO DIRECTORY+0 12 TIMES
	CALL	WRFCB			; AND WRITE DIRECTORY ON DISK
	CALL	SEARCN			; SEARCH NEXT FILE
	JR	RENAM0			; AND TEST IT
;
; CHANGE STATUS FILE
;
CSTAT:	CALL	CHKRO			; CHECK DISK R/O
	LD	A,#12			; NUMBER OF BYTES TO SEARCH FOR
	CALL	SEARCH			; SEARCH FILE
CSTAT0:	CALL	TSTFCT			; TEST IF FILE FOUND
	RET	Z			; NOT THEN EXIT
	LD	BC,#(12*256)+0		; COPY FCB+0 TO DIRECTORY+0 12 TIMES
	CALL	WRFCB			; AND WRITE DIRECTORY TO DISK
	CALL	SEARCN			; SEARCH NEXT FILE
	JR	CSTAT0			; AND TEST IT
;
; COMPUTE FILE SIZE
;
FILSZ:	LD	BC,#0			; RESET FILE SIZE LENGTH
	LD	D,C
	CALL	LDRRC			; SAVE IT IN FCB+33,34,35
	LD	A,#12			; NUMBER OF BYTES TO SEARCH FOR
	CALL	SEARCH			; SEARCH FILE
FILSZ0:	CALL	TSTFCT			; TEST IF FILE FOUND
	RET	Z			; NOT THEN EXIT
	CALL	CALDIR			; GET DIRECTORY ENTRY
	EX	DE,HL			; COPY TO DE
	LD	HL,#15			; OFFSET TO NEXT RECORD
	CALL	CALRRC			; CALCULATE RANDOM RECORD COUNT
	LD	A,D			; TEST LSB < 33(IX)
	SUB	33(IX)
	LD	A,C			; TEST ISB < 34(IX)
	SBC	A,34(IX)
	LD	A,B			; TEST MSB < 35(IX)
	SBC	A,35(IX)
	CALL	NC,LDRRC		; WRITE NEW MAXIMUM
	CALL	SEARCN			; SEARCH NEXT FILE
	JR	FILSZ0			; AND TEST IT
;
; WRITE FCB ON DISK
;
WRFCB:	CALL	CALDIR			; GET DIRECTORY ENTRY
	PUSH	HL			; SAVE POINTER
	LD	A,(HL)			; GET USER CODE
	EX	DE,HL			; COPY TO DE
	PUSH	IX			; SAVE FCB ENTRY
	POP	HL			; GET IT IN HL
	PUSH	BC			; SAVE BC
	LD	B,#0			; RESET B FOR ADD
	ADD	HL,BC			; ADD OFFSET FCB
	POP	BC			; RESTORE BC
	LD	C,B			; GET NUMBER OF BYTES TO MOVE
	LD	B,#0			; RESET B FOR LDIR
	LDIR				; MOVE BYTES
	POP	HL			; GET POINTER USER CODE
	LD	(HL),A			; RESTORE IT
WRFCB1:	CALL	STDIR			; CALCULATE SECTOR/TRACK DIRECTORY
	JP	WRITDR			; WRITE DIRECTORY ON DISK
;
; FIND FILE
;
FINDF:	LD	A,#15			; NUMBER OF BYTES TO SEARCH FOR 
	CALL	SEARCH			; SEARCH FILE
	CALL	TSTFCT			; TEST IF FILE PRESENT
	RET	NZ			; YES THEN EXIT
	LD	A,(RDWR)		; TEST IF WRITE FUNCTION
	OR	A			
	RET	NZ			; YES THEN EXIT
	LD	A,(SEARQU)		; TEST IF QUESTION MARK USED
	OR	A
	RET	NZ			; YES THEN EXIT
	LD	HL,(PATH)		; GET PATH ADDRESS
	LD	A,H			; TEST IF ZERO (NO PATH)
	OR	L
	RET	Z			; YES THEN EXIT
FINDF0:	LD	A,(HL)			; GET FIRST ENTRY PATH NAME
	INC	HL			; INCREMENT POINTER
	OR	A			; TEST IF LAST ENTRY
	JP	Z,SEARC8		; YES THEN ERROR EXIT 
	AND	#0x7F			; MASK DRIVE NUMBER
	CP	#DOLLAR			; TEST IF CURRENT DRIVE
	JR	NZ,FINDF1		; NO THEN JUMP
	LD	A,(DRIVE)		; GET CURRENT DRIVE
	INC	A			; INCREMENT DRIVE NUMBER
FINDF1:	DEC	A			; DECREMENT DRIVE NUMBER
	PUSH	HL			; SAVE PATH POINTER
	CALL	SELDK			; SELECT DRIVE
	POP	HL			; RESTORE PATH POINTER
	LD	A,(HL)			; GET USER NUMBER
	INC	HL			; ADVANCE POINTER
	AND	#0x7F			; MASK USER NUMBER
	CP	#DOLLAR			; TEST IF CURRENT USER
	JR	NZ,FINDF2		; NO THEN JUMP
	LD	A,(USER)		; GET CURRENT USER
FINDF2:	AND	#0x1F			; MASK USER NUMBER
	LD	B,A			; SAVE IT
	LD	A,(IX)		; GET FCB BYTE 0
	AND	#0xE0			; REMOVE USER NUMBER
	OR	B			; ADD NEW USER NUMBER
	LD	(IX),A		; AND SAVE IT
	PUSH	HL			; SAVE PATH POINTER
	LD	A,#15			; SET NUMBER OF BYTES TO SEARCH FOR
	CALL	SEARCH			; SEARCH FILE 
	CALL	TSTFCT			; TEST IF FILE PRESENT
	POP	HL			; RESTORE PATH POINTER
	JR	Z,FINDF0		; NO THEN TEST NEXT PATH ENTRY
	PUSH	HL			; SAVE PATH POINTER
	CALL	CALDIR			; GET DIRECTORY ENTRY
	LD	DE,#10			; ADD OFFSET SYSTEM BIT
	ADD	HL,DE
	BIT	7,(HL)			; TEST SYSTEM FILE
	POP	HL			; RESTORE PATH POINTER
	JR	Z,FINDF0		; NO SYSTEM FILE THEN TEST NEXT PATH
					;  ENTRY
	LD	A,(DEFDRV)		; GET CURRENT DRIVE
	INC	A			; INCREMENT DRIVE NUMBER
	LD	(FCB0),A		; SAVE IT IN EXIT FCB0
	RET				; AND RETURN TO CALLER
;
; OPEN FILE COMMAND
;
CMND15:	
	CALL	SELDRV			; SELECT DRIVE FROM FCB
	LD	14(IX),#0		; CLEAR FCB+14
;
; OPEN FILE
;
OPENF:	CALL	FINDF			; FIND FILE (USE PATH NAME)
	CALL	TSTFCT			; TEST FILE FOUND
	RET	Z			; NO THEN EXIT
OPENF0:	LD	A,12(IX)		; GET EXTENT NUMBER FROM FCB
	PUSH	AF			; SAVE IT
	CALL	CALDIR			; GET DIRECTORY ENTRY
	PUSH	IX			; SAVE FCB ENTRY
	POP	DE			; GET IN IN DE
	LD	BC,#32			; NUMBER OF BYTES TO MOVE
	LDIR				; MOVE DIRECTORY TO FCB
	SET	7,14(IX)		; SET FCB/FILE NOT MODIFIED
	LD	B,12(IX)		; GET EXTENT NUMBER
	LD	C,15(IX)		; GET NEXT RECORD NUMBER
	POP	AF			; GET OLD EXTENT NUMBER
	LD	12(IX),A		; SAVE IT
	CP	B			; COMPARE OLD AND NEW EXTENT NUMBER
	JR	Z,OPENF1		; SAME THEN JUMP
	LD	C,#0			; SET NEXT RECORD COUNT TO 0
	JR	NC,OPENF1		; OLD EXTENT >= NEW EXTENT THEN JUMP
	LD	C,#0x80			; SET NEXT RECORD COUNT TO MAXIMUM
OPENF1:	LD	15(IX),C		; SAVE NEXT RECORD COUNT
	RET				; AND RETURN TO CALLER
;
; CLOSE FILE COMMAND
;
CMND16:	CALL	SELDRV			; SELECT DRIVE FROM FCB
;
; CLOSE FILE
;
CLOSE:	BIT	7,14(IX)		; TEST FCB/FILE MODIFIED
	RET	NZ			; NOT THEN NO CLOSE REQUIRED
	CALL	CHKRO			; TEST DISK R/O
	LD	A,#15			; NUMBER OF BYTES TO SEARCH FOR
	CALL	SEARCH			; SEARCH FILE
	CALL	TSTFCT			; TEST FILE PRESENT
	RET	Z			; NO THEN EXIT
	CALL	CHKFRO			; CHECK FILE R/O
	CALL	CALDIR			; GET DIRECTORY ENTRY
	LD	BC,#16			; OFFSET TO DM BLOCK 
	ADD	HL,BC			; ADD OFFSET
	EX	DE,HL			; SAVE HL IN DE
	PUSH	IX			; SAVE FCB POINTER
	POP	HL			; GET IT IN HL
	ADD	HL,BC			; ADD OFFSET
	LD	A,(MAXLEN+1)		; TEST NUMBER OF BLOCK >= 256
	OR	A			
	JR	Z,CLOSE0		; NO THEN JUMP
	DEC	B			; SET FLAG
CLOSE0:	CALL	COPYDM			; COPY AND TEST BLOCKS
	EX	DE,HL			; EXCHANGE COPY DIRECTION
	CALL	COPYDM			; COPY AND TEST BLOCKS
	EX	DE,HL			; EXCHANGE COPY DIRECTION
	JR	NZ,CLOSE4		; BLOCK NOT THE SAME THEN ERROR
	INC	HL			; INCREMENT POINTER FCB
	INC	DE			; INCREMENT POINTER DIRECTORY
	BIT	0,B			; TEST NUMBER OF BLOCK >= 256
	JR	Z,CLOSE1		; NO THEN JUMP
	INC	HL			; INCREMENT POINTER FCB
	INC	DE			; INCREMENT POINTER DIRECTORY
	DEC	C			; DECREMENT COUNTER
CLOSE1:	DEC	C			; DECREMENT COUNTER
	JR	NZ,CLOSE0		; NOT READY THEN JUMP
	LD	HL,#-20			; ADD -20 TO GET EXTENT NUMBER
	ADD	HL,DE			; HL CONTAINS POINTER TO EXTENT NUMBER
	LD	A,12(IX)		; GET EXTENT NUMBER FCB
	CP	(HL)			; COMPARE WITH EXTENT NUMBER DIRECTORY
	JR	C,CLOSE3		; FCB < DIRECTORY THEN JUMP
	LD	(HL),A			; SAVE EXTENT NUMBER IN DIRECTORY
	INC	HL			; GET POINTER TO NEXT RECORD
	INC	HL
	INC	HL
	LD	A,15(IX)		; GET NEXT RECORD FCB
;
; THESE LINES HAVE TO BE REMOVED TO LET SUBMIT WORK CORRECTLY
;
;	JR	NZ,CLOSE2		; EXTENTS NOT EQUAL THEN JUMP
;	CP	(HL)			; TEST FCB < DIRECTORY
;	JR	C,CLOSE3		; IF SO THEN JUMP
;
CLOSE2:	LD	(HL),A			; SAVE NEXT RECORD IN DIRECTORY
CLOSE3:	
	.IF	DOTIME==TRUE
	LD	E,#5			; SET LAST UPDATE DATE/TIME
	CALL	STIME			; UPDATE TIME
	.ENDIF
	JP	WRFCB1			; WRITE FCB ON DISK
CLOSE4:	LD	A,#0xFF			; FLAG ERROR
	LD	(PEXIT),A 
	RET				; AND RETURN TO CALLER
;
; COPY AND TEST DISK MAP
;  ENTRY : HL : POINTER TO FIRST FCB
;          DE : POINTER TO SECOND FCB
;          B  : 000H LESS THEN 256 BLOCKS
;               0FFH MORE OR EQUAL TO 256 BLOCKS
;  EXIT  : ZERO : 1 BLOCKS ARE THE SAME
;                 0 BLOCKS ARE NOT THE SAME
;
COPYDM:	LD	A,(HL)			; GET BYTE FIRST FCB
	BIT	0,B			; TEST NUMBER OF BLOCKS >=256
	JR	Z,COPYD0		; NO THEN JUMP
	INC	HL			; INCREMENT POINTER
	OR	(HL)			; TEST BYTE =0
	DEC	HL			; DECREMENT POINTER
COPYD0:	OR	A			; TEST BLOCK NUMBER IS ZERO
	JR	NZ,COPYD1		; NO THEN COMPARE BLOCKS
	LD	A,(DE)			; COPY BLOCK FROM OTHER FCB IN EMPTY 
					; LOCATION
	LD	(HL),A 
	BIT	0,B			; TEST NUMBER OF BLOCKS >=256
	RET	Z			; NO THEN EXIT
	INC	HL			; INCREMENT TO MSB BLOCK NUMBERS
	INC	DE
	LD	A,(DE)			; COPY BLOCK FROM OTHER FCB IN EMPTY 
					; LOCATION
	LD	(HL),A
	JR	COPYD2			; JUMP TRICK TO SAVE SPACE
COPYD1:	LD	A,(DE)			; GET BLOCK NUMBER FIRST FCB
	SUB	(HL)			; TEST IF THE SAME
	RET	NZ			; NOT THEN RETURN
	OR	B			; TEST IF >=256 BLOCKS
	RET	Z			; NO THEN RETURN
	INC	HL			; INCREMENT TO MSB BLOCK NUMBERS
	INC	DE
COPYD2:	LD	A,(DE)			; GET BLOCK NUMBER FIRST FCB
	SUB	(HL)			; TEST IF THE SAME
	DEC	HL			; DECREMENT BLOCK FCB POINTERS
	DEC	DE
	RET				; AND EXIT TO CALLER
;
; MAKE FILE COMMAND
;
CMND22:	CALL	SELDRV			; SELECT DRIVE FROM FCB
	LD	14(IX),#0		; CLEAR FCB+14
;
; MAKE FILE
;
MAKE:
	CALL	CHKRO			; CHECK DRIVE R/O
	LD	A,(IX)		; GET FIRST BYTE FCB
	PUSH	AF			; SAVE IT
	LD	(IX),#0xE5		; SET FIRST BYTE TO EMPTY FILE
	LD	A,#1			; SEARCH FOR 1 BYTE
	CALL	SEARCH			; SEARCH EMPTY FILE
	POP	AF			; GET FIRST BYTE FCB
	LD	(IX),A		; RESTORE IT
	CALL	TSTFCT			; TEST EMPTY FILE FOUND
	RET	Z			; NO THEN RETURN ERROR
	XOR	A			; CLEAR FCB+13
	LD	13(IX),A
	PUSH	IX			; SAVE FCB POINTER
	POP	HL			; GET IT BACK IN HL
	LD	DE,#15			; PREPARE OFFSET
	ADD	HL,DE			; ADD IT
	LD	B,#17			; SET LOOP COUNTER
MAKE0:	LD	(HL),A			; CLEAR FCB+15 UNP TO FCB+31
	INC	HL			; INCREMENT POINTER
	DJNZ	MAKE0			; AND CLEAR ALL BYTES
	CALL	CALDIR			; GET DIRECTORY ENTRY
	LD	A,(IX)		; GET FIRST BYTE FCB
	LD	(HL),A			; SAVE IT IN DIRECTORY (WRITE FCB 
					; NEEDS THIS)
	.IF	DOTIME==TRUE
	LD	E,#1			; SET CREATION DATE/TIME
	CALL	STIME			; UPDATE TIME IN DIRECTORY 
	LD	E,#5			; SET LAST UPDATE DATE/TIME
	CALL	STIME			; UPDATE TIME IN DIRECTORY
	.ENDIF
;
	LD	BC,#(32*256)+0		; COPY FCB+0 TO DIRECTOTY+0 32 TIMES
	CALL	WRFCB			; WRITE FCB ON DISK
	SET	7,14(IX)		; SET FCB/FILE NOT MODIFIED
	RET				; AND RETURN TO CALLER
;
; OPEN NEXT EXTENT
;
OPENEX:	BIT	7,14(IX)		; TEST IF FCB/FILE MODIFIED (WRITE)
	JR	NZ,OPENX4		; NOT THEN JUMP
	CALL	CLOSE			; CLOSE CURRENT FCB
	LD	A,(PEXIT)		; GET EXIT CODE
	INC	A			; TEST IF ERROR
	RET	Z			; YES THEN EXIT
	CALL	CALNEX			; CALCULATE NEXT EXTENT
	JR	C,OPENX3		; ERROR THEN JUMP
	JR	NZ,OPENX5		; FCB PRESENT FROM CLOSE THEN JUMP
OPENX1:	LD	A,#15			; SEARCH FIRST 15 BYTES
	CALL	SEARCH			; SEARCH FOR FILE
OPENX2:	CALL	TSTFCT			; TEST IF FILE FOUND
	JR	NZ,OPENX5		; YES THEN JUMP
	LD	A,(RDWR)		; TEST READ/WRITE FLAG
	OR	A			; TEST IF READ
	JR	Z,OPENX3		; YES THEN ERROR
	CALL	MAKE			; MAKE NEW EXTENT IF WRITE
	CALL	TSTFCT			; TEST IF SUCCESFULL
	JR	NZ,OPENX6		; YES THEN EXIT
OPENX3:	SET	7,14(IX)		; SET FCB/FILE NOT MODIFIED 
	LD	A,#0xFF			; SET EXIT CODE
	JR	OPENX7
OPENX4:	CALL	CALNEX			; CALCULATE NEXT EXTENT
	JR	C,OPENX3		; ERROR THEN JUMP
	BIT	7,1(IX)		; TEST SYSTEM FILE BIT
	JR	Z,OPENX1		; NO SYSTEM FILE THEN JUMP
	CALL	FINDF			; SEARCH PATH FOR FILE
	JR	OPENX2			; USE SAME ROUTINE
OPENX5:	CALL	OPENF0			; OPEN FILE
OPENX6:	XOR	A			; AND CLEAR EXIT CODE
OPENX7:	LD	(PEXIT),A
	RET
;
; CALCULATE NEXT EXTENT
;  EXIT: CARRY=1 => OVERFLOW DETECTED
;        ZERO =1 => SEARCH NEXT EXTENT
;	 ZERO =0 => NEXT EXTENT PRESENT (CLOSE)
;
CALNEX:	LD	B,12(IX)		; GET EXTENT NUMBER
	LD	C,14(IX)		; GET FCB+14
	BIT	6,C			; TEST ERROR BIT RANDOM RECORD
	SCF				; SET ERROR FLAG
	RET	NZ			; NON ZERO THEN ERROR EXIT
	INC	B			; INCREMENT EXTENT NUMBER
	LD	A,B			; GET EXTENT NUMBER
	AND	#0x1F			; MASK IT
	LD	B,A			; SAVE IT IN B
	JR	NZ,CALNX0		; NON ZERO THEN JUMP
	INC	C			; INCREMENT FCB+14
	LD	A,C			; GET IT IN A
	AND	#0x3F			; MASK IT
	LD	C,A			; SAVE IT IN C
	SCF				; SET ERROR FLAG
	RET	Z			; AND RETURN IF FILE OVERFLOW
	XOR	A			; CLEAR ZERO FLAG (NOT SAME EXTENT)
	JR	CALNX1			; AND SAVE EXTENT NUMBER AND FCB+14
CALNX0:	LD	A,(NEXTND)		; GET NEXT EXTENT MASK
	AND	B			; TEST IF SAME EXTENT (CLOSE)
CALNX1:	LD	12(IX),B		; SAVE EXTENT NUMBER
	LD	14(IX),C		; SAVE FCB+14
	RET				; AND RETURN TO CALLER
;
; READ RANDOM RECORD COMMAND
;
CMND33:	CALL	SELDRV			; SELECT DRIVE FROM FCB
;
; READ RANDOM SECTOR
;
RDRAN:	XOR	A			; SET READ/WRITE FLAG
	CALL	LDFCB			; LOAD RANDOM RECORD IN FCB
	JR	Z,READS			; NO ERROR THEN READ SECTOR
	RET				; RETURN ERROR 
;
; READ SEQUENTIAL
;
CMND20:	CALL	SELDRV			; SELECT DRIVE FROM FCB
;
; READ SECTOR
;
READS:	XOR	A			; SET READ/WRITE FLAG
	LD	(RDWR),A		; SAVE IT
	LD	A,32(IX)		; GET RECORD COUNTER
	CP	#0x80			; TEST IF LAST RECORD THIS EXTENT
	JR	NC,READS1		; YES THEN OPEN NEXT EXTENT
	CP	15(IX)			; TEST IF GREATER THEN CURRENT RECORD
	JR	C,READS2		; NO THEN GET RECORD
READS0:	LD	A,#1			; SET END OF FILE FLAG
	LD	(PEXIT),A		; SAVE IT
	RET				; AND RETURN TO CALLER
READS1:	CALL	OPENEX			; OPEN NEXT EXTENT
	LD	A,(PEXIT)		; GET EXIT CODE
	OR	A
	JR	NZ,READS0		; YES THEN END OF FILE
	LD	32(IX),#0		; CLEAR RECORD COUNTER
READS2:	CALL	GETDM			; GET BLOCK NUMBER FROM DM IN FCB
	LD	A,D			; TEST BLOCK NUMBER = 0
	OR	E
	JR	Z,READS0		; YES THEN END FILE
	CALL	CALSEC			; CALCULATE SECTOR NUMBER (128 BYTES)
	CALL	CALST			; CALCULATE SECTOR/TRACK NUMBER
	CALL	READR			; READ DATA
	LD	A,(FUNCT)		; GET FUNCTION NUMBER
	CP	#20			; TEST IF READ SEQUENTIAL
	RET	NZ			; NO THEN RETURN
	INC	32(IX)			; INCREMENT NEXT RECORD COUNTER
	RET				; AND RETURN TO CALLER
;
; WRITE RANDOM SECTOR WITH ZERO FILL COMMAND
;
CMND40:					; Zero fill is done in WRITES
;
;
; WRITE RANDOM RECORD COMMAND
;
CMND34:	CALL	SELDRV			; SELECT DRIVE FROM FCB
;
; WRITE RANDOM SECTOR
;
WRRAN:	LD	A,#0xFF			; SET READ/WRITE FLAG
	CALL	LDFCB			; LOAD FCB FROM RANDOM RECORD
	JR	Z,WRITES		; NO ERROR THEN WRITE RECORD
	RET				; RETURN ERROR
;
; WRITE SEQUENTIAL
;
CMND21:	CALL	SELDRV			; SELECT DRIVE FROM FCB
;
; WRITE SECTOR
;
WRITES:	LD	A,#0xFF			; SET READ/WRITE FLAG
	LD	(RDWR),A		; AND SAVE IT
	CALL	CHKRO			; CHECK DISK R/O
	PUSH	IX			; SAVE FCB POINTER
	POP	HL			; GET IT BACK IN HL
	CALL	CHKFR0			; CHECK FILE R/O
	LD	A,32(IX)		; GET RECORD COUNT
	CP	#0x80			; TEST IF END THIS EXTENT
	JR	C,WRITS0		; YES THEN OPEN NEXT EXTENT
	CALL	OPENEX			; OPEN NEXT EXTENT
	LD	A,(PEXIT)		; GET ERROR CODE
	OR	A		
	JP	NZ,WRITS9		; ERROR THEN DIRECTORY FULL ERROR
	LD	32(IX),#0		; CLEAR RECORD COUNTER
WRITS0:	CALL	GETDM			; GET BLOCK NUMBER FROM FCB
	LD	A,D			; TEST IF BLOCK NUMBER = 0
	OR	E
	JR	NZ,WRITS5		; NO THEN WRITE SECTOR
	PUSH	HL			; SAVE POINTER TO BLOCK NUMBER
	LD	A,C			; TEST FIRST BLOCK NUMBER IN EXTENT
	OR	A
	JR	Z,WRITS1		; YES THEN JUMP
	DEC	A			; DECREMENT POINTER TO BLOCK NUMBER
	CALL	GETDM4			; GET PREVIOUS BLOCKNUMBER
WRITS1:	CALL	GETFRE			; GET NEAREST FREE BLOCK
	POP	HL			; GET POINTER TO BLOCK NUMBER
	LD	A,D			; TEST IF BLOCKNUMBER = 0
	OR	E
	JR	Z,WRITS8		; YES THEN DISK FULL ERROR
	RES	7,14(IX)		; RESET FCB/FILE MODIFIED
	LD	(HL),E			; SAVE BLOCKNUMBER
	LD	A,(MAXLEN+1)		; GET NUMBER OF BLOCKS
	OR	A			; TEST IF <256
	JR	Z,WRITS2		; YES THEN JUMP
	INC	HL			; INCREMENT TO MSB BLOCK NUMBER
	LD	(HL),D			; SAVE MSB BLOCK NUMBER
WRITS2:	LD	C,#2			; SET WRITE NEW BLOCK FLAG
	LD	A,(FUNCT)		; GET FUNCTION NUMBER
	SUB	#40			; TEST IF WRITE RR WITH ZERO FILL
	JR	NZ,WRITS6		; NO THEN JUMP
	PUSH	DE			; SAVE BLOCKNUMBER
 	LD	HL,#DIRBUF		; USE DIRECTORY BUFFER FOR ZERO FILL
	LD	B,#128			; 128 BYTES TO CLEAR
WRITS3:	LD	(HL),A			; CLEAR DIRECTORY BUFFER
	INC	HL			; INCREMENT POINTER
	DJNZ	WRITS3			; CLEAR ALL BYTES
	CALL	CALSEC			; CALCULATE SECTOR NUMBER (128 BYTES)
	LD	A,(NMASK)		; GET SECTOR MASK
	LD	B,A			; COPY IT
	INC	B			; INCREMENT IT TO GET NUMBER OF WRITES
	CPL				; COMPLEMENT SECTOR MASK
	AND	E			; MASK SECTOR NUMBER
	LD	E,A			; AND SAVE IT
	LD	C,#2			; SET WRITE NEW BLOCK FLAG
WRITS4:	PUSH	HL			; SAVE REGISTERS
	PUSH	DE
	PUSH	BC
	CALL	CALST			; CALCULATE SECTOR/TRACK
	CALL	DMADIR			; SET DMA DIRECTORY BUFFER
	POP	BC			; GET WRITE NEW BLOCK FLAG
	PUSH	BC			; SAVE IT AGAIN
	CALL	WRITER			; WRITE RECORD ON DISK
	POP	BC			; RESTORE REGISTERS
	POP	DE
	POP	HL
	LD	C,#0			; CLEAR WRITE NEW BLOCK FLAG
	INC	E			; INCREMENT SECTOR NUMBER
	DJNZ	WRITS4			; WRITE ALL BLOCKS
	CALL	STDMA			; SET USER DMA ADDRESS
	POP	DE			; GET BLOCK NUMBER
WRITS5:	LD	C,#0			; CLEAR WRITE NEW BLOCK FLAG 
WRITS6:	RES	7,14(IX)		; RESET FCB/FILE MODIFIED FLAG
	PUSH	BC			; SAVE IT
	CALL	CALSEC			; CALCULATE SECTOR NUMBER (128 BYTES)
	CALL	CALST			; CALCULATE SECTOR/TRACK
	POP	BC			; GET WRITE NEW BLOCK FLAG
	CALL	WRITER			; WRITE RECORD ON DISK
	LD	A,32(IX)		; GET RECORD COUNTER
	CP	15(IX)			; COMPARE WITH NEXT RECORD
	JR	C,WRITS7		; IF LESS THEN JUMP
	INC	A			; INCREMENT RECORD COUNT 
	LD	15(IX),A		; SAVE IT ON NEXT RECORD POSITION
	RES	7,14(IX)		; RESET FCB/FILE MODIFIED FLAG
WRITS7:	LD	A,(FUNCT)		; GET FUNCTION NUMBER
	CP	#21			; TEST WRITE SEQUENTIAL
	RET	NZ			; NOT THEN RETURN
	INC	32(IX)			; INCREMENT RECORD COUNT
	RET				; AND RETURN TO CALLER
WRITS8:	LD	A,#2			; SET DISK FULL ERROR
	LD	(PEXIT),A
	RET				; AND RETURN TO CALLER
WRITS9:	LD	A,#1			; SET DIRECTORY FULL FLAG
	LD	(PEXIT),A
	RET				; AND RETURN TO CALLER
;
; LOAD FCB FOR RANDOM READ/WRITE
;  EXIT : ZERO FLAG : 1 NO ERROR
;                     0 ERROR OCCURED
;
LDFCB:	LD	(RDWR),A		; SAVE READ/WRITE FLAG
	LD	A,33(IX)		; GET FIRST BYTE RANDOM RECORD
	LD	D,A			; SAVE IT IN D
	RES	7,D			; RESET MSB TO GET NEXT RECORD
	RLA				; SHIFT MSB IN CARRY
	LD	A,34(IX)		; LOAD NEXT BYTE RANDOM RECORD
	RLA				; SHIFT CARRY
	PUSH	AF			; SAVE IT
	AND	#0x1F			; MASK NEXT EXTENT
	LD	C,A			; SAVE IT IN C
	POP	AF			; GET BYTE
	RLA				; SHIFT 4 TIMES
	RLA
	RLA
	RLA
	AND	#0xF			; MASK IT
	LD	B,A			; SAVE FCB+14
	LD	A,35(IX)		; GET NEXT BYTE RANDOM RECORD
	LD	E,#6			; SET RANDOM RECORD TO LARGE FLAG
	CP	#4			; TEST RANDOM RECORD TO LARGE 
	JR	NC,LDFCB8		; YES THEN ERROR
	RLCA				; SHIFT 4 TIMES
	RLCA
	RLCA
	RLCA
	ADD	A,B			; ADD BYTE
	LD	B,A			; SAVE FCB+14 IN B
	LD	32(IX),D		; SET NEXT RECORD COUNT
	LD	D,14(IX)		; GET FCB+14
	BIT	6,D			; TEST ERROR RANDOM RECORD
	JR	NZ,LDFCB0		; YES THEN JUMP
	LD	A,C			; GET NEW EXTENT NUMBER
	CP	12(IX)			; COMPARE WITH FCB
	JR	NZ,LDFCB0		; NOT EQUAL THEN OPEN NEXT EXTENT
	LD	A,B			; GET NEW FCB+14
	XOR	14(IX)			; COMPARE WITH FCB+14
	AND	#0x3F			; MASK IT
	JR	Z,LDFCB6		; EQUAL THEN RETURN
LDFCB0:	BIT	7,D			; TEST FCB MODIFIED (WRITE)
	JR	NZ,LDFCB1		; NO THEN JUMP
	PUSH	DE			; SAVE REGISTERS
	PUSH	BC
	CALL	CLOSE			; CLOSE EXTENT
	POP	BC			; RESTORE REGISTERS
	POP	DE
	LD	E,#3			; SET CLOSE ERROR
	LD	A,(PEXIT)		; GET EXIT CODE
	INC	A
	JR	Z,LDFCB7		; ERROR THEN EXIT
LDFCB1:	LD	12(IX),C		; SAVE NEW EXTENT NUMBER
	LD	14(IX),B		; SAVE NEW FCB+14
	BIT	7,D			; TEST FCB MODIFIED (PREVIOUS FCB)
	JR	NZ,LDFCB3		; NO THEN JUMP
LDFCB2:	LD	A,#15			; SET NUMBER OF BYTES TO SEARCH FOR
	CALL	SEARCH			; SEARCH NEXT FCB
	JR	LDFCB4			; JUMP
LDFCB3:	BIT	7,1(IX)		; TEST IF SYSTEM FILE
	JR	Z,LDFCB2		; NO USE SEARCH
	CALL	FINDF			; OPEN FILE (USE PATH NAME)
LDFCB4:	LD	A,(PEXIT)		; GET ERROR CODE
	INC	A
	JR	NZ,LDFCB5		; NO ERROR THEN EXIT
	LD	A,(RDWR)		; GET READ/WRITE FLAG
	LD	E,#4			; SET READ EMPTY RECORD
	INC	A
	JR	NZ,LDFCB7		; READ THEN ERROR
	CALL	MAKE			; MAKE MEW FCB
	LD	E,#5			; SET MAKE ERROR
	LD	A,(PEXIT)		; GET ERROR CODE
	INC	A
	JR	Z,LDFCB7		; ERROR THEN EXIT
	JR	LDFCB6			; NO ERROR EXIT (ZERO SET)
LDFCB5:	CALL	OPENF0			; OPEN FILE
LDFCB6:	XOR	A			; SET ZERO FLAG AND CLEAR ERROR CODE
	LD	(PEXIT),A
	RET				; AND RETURN TO CALLER
LDFCB7:	LD	14(IX),#0xC0		; SET RANDOM RECORD ERROR
LDFCB8:	LD	A,E			; GET ERROR CODE
	LD	(PEXIT),A		; AND SAVE IT
	SET	7,14(IX)		; SET FCB/FILE NOT MODIFIED
	OR	A			; CLEAR ZERO FLAG
	RET				; AND RETURN TO CALLER
;
; CALCULATE RANDOM RECORD
;  ENTRY HL=OFFSET IN FCB
;        DE=FCB POINTER
;  EXIT  D=LSB RANDOM RECORD
;        C=ISB RANDOM RECORD
;        B=MSB RANDOM RECORD
;
CALRRC:	ADD	HL,DE			; POINTER TO FCB+15 OR FCB+32
	LD	A,(HL)			; GET BYTE
	LD	HL,#12			; OFFSET TO EXTENT NUMBER
	ADD	HL,DE			; GET POINTER TO EXTENT BYTE
	LD	D,A			; SAVE FIRST BYTE
	LD	A,(HL)			; GET EXTENT BYTE
	AND	#0x1F			; MASK IT
	RL	D			; SHIFT MSB IN CARRY
	ADC	A,#0			; ADD CARRY
	RRA				; SHIFT 1 TIME (16 BITS)
	RR	D
	LD	C,A			; SAVE ISB
	INC	HL			; INCREMENT TO FCB+14
	INC	HL
	LD	A,(HL)			; GET FCB+14
	RRCA				; SHIFT 4 TIMES
	RRCA
	RRCA
	RRCA
	PUSH	AF			; SAVE IT
	AND	#3			; MASK MSB
	LD	B,A			; SAVE IT
	POP	AF			; GET LSB
	AND	#0xF0			; MASK IT
	ADD	A,C			; ADD WITH ISB
	LD	C,A			; SAVE ISB
	RET	NC			; NO CARRY THEN RETURN
	INC	B			; INCREMENT MSB
	RET				; AND RETURN TO CALLER
;
; SET TIME AND DATE
;  ENTRY: E : 1 : SET CREATION TIME/DATE
;             5 : SET LAST UPDATE TIME/DATE
;  TIME RETURN POINTER IN HL
;   HL+0 : LOW  BYTE DATE SINCE JAN,1,1978
;   HL+1 : HIGH BYTE DATE SINCE JAN,1,1978
;   HL+2 : HOURS   (BCD)
;   HL+3 : MINUTES (BCD)
;   HL+4 : SECONDS (BCD) (NOT USED IN TIME STAMP)
;	
	.IF	DOTIME==TRUE
STIME:	LD	HL,(DIRBUF)		; GET DIRECTORY ENTRY
	LD	BC,#0x60			; OFFSET ENTRY POINT TIME/DATE STAMP
	ADD	HL,BC			; ADD OFFSET
	LD	A,(HL)			; GET BYTE
	SUB	#0x21			; TEST IF TIME STAMP PRESENT
	RET	NZ			; NO THEN RETURN
	LD	D,A			; CLEAR D
	ADD	HL,DE			; ADD ENTRY (UPDATE/CREATE)
	LD	A,(SECPNT)		; GET SECTOR POINTER
	RRCA				; SHIFT 2 TIMES
	RRCA
	LD	E,A			; SAVE IT
	RRCA				; SHIFT 2 TIMES
	RRCA
	ADD	A,E			; ADD IT (A=0,10,20)
	LD	E,A			; SAVE IN E
	ADD	HL,DE			; ADD OFFSET
	PUSH	HL			; SAVE RESULT
	LD	C,#0			; RETURN POINTER IN HL
					; C=FF MEANS SET DATE POINTED TO BY HL
	CALL	BTIME			; RETURN POINTER IN HL
	POP	DE			; GET POINTER
	LD	BC,#4			; SET 4 BYTES
	LDIR				; COPY 4 BYTES
	RET				; AND RETURN TO CALLER
;
; GET TIME
;
GETTIM:	PUSH	DE			; SAVE ADDRESS TO PUT TIME 
	LD	C,#0			; GET TIME ADDRESS
	CALL	BTIME			; EXECUTE P2BIOS CALL
	POP	DE			; RESTORE ADDRESS TO PUT TIME
	LD	BC,#5			; 5 BYTES TO MOVE
	LDIR				; STORE THE TIME
	RET				; AND RETURN TO CALLER
;
; SET TIME
;
SETTIM:	EX	DE,HL			; GET ADDRESS TIME IN HL 
	LD	C,#0xFF			; SET TIME ADDRESS
					; AND FALL THROUGH TO P2BIOS CALL 
;
; EXECUTE P2BIOS TIME ROUTINE
;
BTIME:	PUSH	HL			; SAVE VALUE IN HL
	LD	HL,(TIMEAD)		; GET ADDRESS TIME ROUTINE
	EX	(SP),HL			; PUT ADDRESS ON STACK AND RESTORE HL
	RET				; EXECUTE TIME ROUTINE
;
	.ENDIF	
;
; P2DOS EXIT ROUTINE
;
P2EXIT:	LD	A,(FLDRV)		; TEST DRIVE SELECT USED FLAG
	OR	A			
	JR	Z,P2EXT0		; NO THEN EXIT
	LD	A,(FCB0)		; GET FCB BYTE 0
	LD	(IX),A		; SAVE IT
	LD	A,(DRIVE)		; GET OLD DRIVE NUMBER
	CALL	SELDK			; SELECT DISK
P2EXT0:	PUSH	IX			; SAVE IX
	POP	DE			; RESTORE DE
	POP	IX			; RESTORE IX
	LD	SP,(SPSAVE)		; GET OLD SP
	LD	HL,(PEXIT)		; GET EXIT CODE
	LD	A,(FUNCT)		; GET FUNCTION CODE
	LD	C,A			; RESTORE C
	LD	A,L			; COPY FUNCTION CODE
	LD	B,H
	RET				; AND RETURN TO CALLER
;
; RAM AREA
;
TABCNT:	.DB	0			; TAB COUNTER
TABCX1:	.DB	0			; TEMPORARY TAB COUNTER (USED BY RDBUF)
FCONTP:	.DB	0			; LIST ENABLE FLAG (CONTROL P)
LASTCH:	.DB	0			; LAST CHARACTER
DELAY:	.DB	0xFF			; DELAY COUNTER
;
TRANS:	.DW	0			; TRANSLATION VECTOR
TEMP0:	.DW	0			; NUMBER OF FILES ON DRIVE 
TEMP1:	.DW	0			; NOT USED 
TEMP2:	.DW	0			; NOT USED
DIRBUF:	.DW	0			; DIRECTORY BUFFER
IXP:	.DW	0			; DISK PARAMETER BLOCK
CSV:	.DW	0			; CHECK SUM POINTER
ALV:	.DW	0			; ALLOCATION VECTOR POINTER
;
MAXSEC:	.DW	0			; MAXIMUM NUMBER OF SECTORS/TRACK
NBLOCK:	.DB	0			; NUMBER OF BLOCKS
NMASK:	.DB	0			; MASK NUMBER OF BLOCKS
NEXTND:	.DB	0			; EXTENT MASK
MAXLEN:	.DW	0			; MAXIMUM BLOCK NUMBER-1
NFILES:	.DW	0			; MAXIMUM NUMBER OF FILES-1
NDIR0:	.DB	0			; FIRST TWO ENTRIES ALV BUFFER
NDIR1:	.DB	0
NCHECK:	.DW	0			; NUMBER OF CHECKSUM ENTRUIES
NFTRK:	.DW	0			; FIRST TRACK NUMBER
;
DSKRO:	.DW	0			; DISK R/O VECTOR
LOGIN:	.DW	0			; LOGIN VECTOR
DMA:	.DW	0x80			; DMA ADDRESS
;
FUNCT:	.DB	0			; FUNCTION NUMBER
PEXIT:	.DW	0			; EXIT CODE
FLDRV:	.DB	0			; DRIVE SELECT USED FLAG
RDWR:	.DB	0			; READ/WRITE FLAG
;
FCB0:	.DB	0			; FCB BYTE 0
USER:	.DB	0			; USER NUMBER
DRIVE:	.DB	0			; DRIVE NUMBER
DEFDRV:	.DB	0			; DEFAULT DRIVE NUMBER
RECDIR:	.DW	0			; RECORD DIRECTORY (CHECKSUM)
FILCNT:	.DW	0			; FILE COUNTER
SECPNT:	.DB	0			; SECTOR POINTER
SUBFLG:	.DB	0			; SUBMIT FLAG (RESET DISK COMMAND)
;
DCOPY:	.DW	0			; COPY ADDRESS FCB
SEAREX:	.DB	0			; EXIT CODE SEARCH
SEARNB:	.DB	0			; SEARCH NUMBER OF BYTES
SEARQU:	.DB	0			; SEARCH QUESTION MARK USED
SEARPU:	.DB	0			; SEARCH PUBLIC FILE
;next flag added by B.H.
DIFF:	.DB	0			; disk changed flag
;
SPSAVE:	.DW	0			; STACK POINTER LOCATION
	.DS	62			; 62 BYTE STACK
P2DOSS:					; P2DOS STACK

	.DB	0			; disk changed flag

	.DB	0x1A, 0x1A ;, 0x1A, 0x1A,  0x1A, 0x1A, 0x1A, 0x1A


;	.ascii	'[BIOS]'
;.include "bios.asm"
